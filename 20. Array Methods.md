# 📘 JavaScript 배열 메서드

---

## 🧱 1. `push()` / `pop()`

> **배열의 끝에 추가하거나 제거**

| 메서드          | 설명                        |
| ------------ | ------------------------- |
| `push(elem)` | 배열 끝에 엘리먼트 추가 → 새 length 리턴 |
| `pop()`      | 배열 끝에서 엘리먼트 제거 → 제거된 엘리먼트 리턴  |

```javascript
const arr = [1, 2];
arr.push(3);      // [1, 2, 3]
arr.pop();        // [1, 2]
```

---

## 🧱 2. `unshift()` / `shift()`

> **배열의 앞에 추가하거나 제거**

| 메서드             | 설명                     |
| --------------- | ---------------------- |
| `unshift(elem)` | 앞에 엘리먼트 추가 → 새 length 리턴 |
| `shift()`       | 앞에서 엘리먼트 제거 → 제거된 엘리먼트 리턴  |

```javascript
const arr = [1, 2];
arr.unshift(0);   // [0, 1, 2]
arr.shift();      // [1, 2]
```

---

## 🔁 3. `forEach(callback)`

> 각 엘리먼트에 대해 콜백 실행 (리턴값 없음)

```javascript
const fruits = ["apple", "banana"];
fruits.forEach((fruit, idx) => {
  console.log(`${idx}: ${fruit}`);
});
```

* 리턴값: ❌ 없음
* **중단 불가** (break/return 불가)

---

## 🧪 4. `map(callback)`

> 각 엘리먼트를 변환한 **새 배열 반환**

```javascript
const nums = [1, 2, 3];
const doubled = nums.map(n => n * 2); // [2, 4, 6]
```

* 원본 배열 유지
* **불변 처리(immutable)** 용도에 적합

---

## 🧹 5. `filter(callback)`

> 조건을 만족하는 엘리먼트만 추출

```javascript
const nums = [1, 2, 3, 4];
const even = nums.filter(n => n % 2 === 0); // [2, 4]
```

---

## 🧮 6. `reduce(callback, init)`

> 누산기(accumulator) 기반 축약 계산

```javascript
const nums = [1, 2, 3];
const sum = nums.reduce((acc, cur) => acc + cur, 0); // 6
```

* 두 번째 파라미터로 초기값 필수 (0, \[], {} 등)
* 복잡한 합산/객체 생성 등에 활용

---

## 🔍 7. `find()` / `findIndex()`

> 조건 만족하는 **첫 엘리먼트 / 인덱스 반환**

```javascript
const users = [{id: 1}, {id: 2}];
users.find(u => u.id === 2);        // {id: 2}
users.findIndex(u => u.id === 2);   // 1
```

* 없으면 `undefined` / `-1` 반환

---

## 📌 8. `includes(elem)`

> 배열에 특정 값 포함 여부

```javascript
[1, 2, 3].includes(2); // true
```

* `NaN`도 탐지 가능 (`indexOf`는 못함)

---

## 🔄 9. `indexOf(elem)` / `lastIndexOf(elem)`

```javascript
[1, 2, 3, 2].indexOf(2);      // 1
[1, 2, 3, 2].lastIndexOf(2);  // 3
```

* 앞에서부터 / 뒤에서부터 인덱스 탐색

---

## 🧩 10. `some()` / `every()`

> 일부 / 전체 조건 만족 여부

```javascript
[1, 2, 3].some(n => n > 2);  // true
[1, 2, 3].every(n => n > 0); // true
```

* `some`: 하나라도 true면 true
* `every`: 모두 true여야 true

---

## ✂️ 11. `slice(start, end)`

> **일부 배열 잘라내기 (원본 유지)**

```javascript
const arr = [1, 2, 3, 4];
arr.slice(1, 3); // [2, 3]
```

* `end`는 포함하지 않음
* `slice()`만 쓰면 복사본 생성

---

## 🛠️ 12. `splice(start, deleteCount, ...items)`

> **원본 수정하며 엘리먼트 추가/삭제**

```javascript
const arr = [1, 2, 3];
arr.splice(1, 1, 9); // [1, 9, 3]
```

* 1번 인덱스부터 1개 제거 후 9 삽입
* 리턴값: 제거된엘리먼트 배열

---

## 🔀 13. `sort()` / `reverse()`

```javascript
[3, 1, 2].sort();         // [1, 2, 3] (디폴트트: 문자열 기준)
[3, 1, 2].sort((a, b) => a - b); // 숫자 정렬
[1, 2, 3].reverse();      // [3, 2, 1]
```

* `sort()`는 **디폴트트로 문자열 기준 정렬**
* `compareFn` 필수로 넣을 것!

---

## 🧵 14. `join(separator)`

> 배열을 문자열로 결합

```javascript
['a', 'b', 'c'].join('-'); // 'a-b-c'
```

---

## 🔁 15. `concat()`

> 배열 병합 (불변)

```javascript
[1, 2].concat([3, 4]); // [1, 2, 3, 4]
```

---

## 🧪 예제 실습: 종합 활용

```javascript
const users = [
  { id: 1, name: "Alice", age: 28 },
  { id: 2, name: "Bob", age: 35 },
  { id: 3, name: "Charlie", age: 30 }
];

// 1. 나이 30 이상인 사용자 이름만 대문자로 추출
const names = users
  .filter(u => u.age >= 30)
  .map(u => u.name.toUpperCase());

console.log(names); // ['BOB', 'CHARLIE']
```

---

## ⚠️ 주의사항 요약

| 메서드                | 원본 변경 | 리턴값       | 주 용도     |
| ------------------ | ----- | --------- | -------- |
| `push`, `pop`      | ✅     | 숫자 / 엘리먼트   | 끝에 추가/제거 |
| `unshift`, `shift` | ✅     | 숫자 / 엘리먼트   | 앞에 추가/제거 |
| `map`, `filter`    | ❌     | 새 배열      | 불변 배열 처리 |
| `splice`           | ✅     | 제거된 엘리먼트 배열 | 중간 삽입/삭제 |
| `slice`            | ❌     | 새 배열      | 일부 복사    |
| `sort`, `reverse`  | ✅     | 정렬된 배열    | 정렬, 뒤집기  |


