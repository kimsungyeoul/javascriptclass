# 🌌 JavaScript `...` 문법

## Spread 연산자 vs Rest 파라미터

JavaScript에서 `...`은 **한 가지 문법이 아니라 “두 가지 역할”** 을 합니다.

* **Spread 연산자(Spread Operator)**
* **Rest 파라미터(Rest Parameters)**

둘 다 똑같이 `...`를 쓰기 때문에 처음 보면 헷갈리지만,
**“어디에 쓰였는가(위치)”** 에 따라 의미가 완전히 달라집니다.

---

## 1. 한 줄 요약부터 🎯

* **Spread 연산자**:

  > “펼쳐라!” → **배열/객체/이터러블을 낱개 요소로 풀어서** 쓰는 문법
  > 위치: **함수 호출, 배열/객체 리터럴의 오른쪽(RHS)**

* **Rest 파라미터**:

  > “모아라!” → **여러 개의 값을 하나의 배열로 모으는** 문법
  > 위치: **함수 파라미터, 구조 분해 할당의 왼쪽(LHS)**

👉 똑같이 `...`를 쓰지만
**Spread는 “펼치는 역할”**,
**Rest는 “모으는 역할”**입니다.

---

## 2. Spread 연산자 🌈 — “펼치는” 역할

### 2-1. 배열에서 Spread

```js
const arr1 = [1, 2];
const arr2 = [3, 4];

const merged = [...arr1, ...arr2];

console.log(merged); // [1, 2, 3, 4]
```

`...arr1` 은 `[1, 2]` → `1, 2` 로 **낱개 요소로 풀어** 넣습니다.

#### ✅ 배열 복사도 가능

```js
const original = [1, 2, 3];
const copy = [...original];

console.log(copy);       // [1, 2, 3]
console.log(copy === original); // false (다른 배열)
```

※ 단, **얕은 복사(shallow copy)** 입니다.
내부에 객체가 있으면 참조는 공유됩니다.

---

### 2-2. 함수 호출에서 Spread

```js
function sum(a, b, c) {
  return a + b + c;
}

const nums = [10, 20, 30];

console.log(sum(...nums)); // sum(10, 20, 30)
```

`sum(...nums)`
→ `sum(10, 20, 30)` 으로 바뀐다고 생각하면 됩니다.

---

### 2-3. 객체에서 Spread (ES2018+)

```js
const user = { id: 1, name: "Kim" };
const extra = { age: 30, country: "KR" };

const merged = { ...user, ...extra };

console.log(merged);
// { id: 1, name: "Kim", age: 30, country: "KR" }
```

#### ✅ 객체 복사

```js
const userCopy = { ...user };
```

역시 **얕은 복사**입니다.

#### ⚠️ 키가 겹치면 뒤에 오는 게 덮어쓴다

```js
const a = { id: 1, name: "A" };
const b = { id: 1, name: "B" };

const merged = { ...a, ...b };
console.log(merged.name); // "B"
```

---

## 3. Rest 파라미터 🌪 — “모으는” 역할

### 3-1. 함수 파라미터에서 Rest

```js
function logAll(...args) {
  console.log(args);
}

logAll(1, 2, 3);
// [1, 2, 3]
```

✅ `...args`는 “호출 시 들어온 인자들을 하나의 배열로 모아라”는 의미입니다.

---

### 3-2. 앞에 고정 파라미터 + 나머지 Rest

```js
function sum(first, ...rest) {
  console.log(first); // 첫 번째 인자
  console.log(rest);  // 나머지 인자들의 배열
}

sum(10, 20, 30, 40);
// first: 10
// rest: [20, 30, 40]
```

* `first` → 10
* `rest` → `[20, 30, 40]`

---

### 3-3. Rest 파라미터 규칙 ⚠️

1. Rest 파라미터는 **항상 마지막에만 올 수 있다**

   ```js
   function fn(...args, x) {} // ❌ 문법 에러
   function fn(x, ...args) {} // ✅ OK
   ```

2. Rest 파라미터는 **반드시 하나만** 올 수 있다

   ```js
   function fn(...a, ...b) {} // ❌ 불가
   ```

Rest 파라미터는

> “남은 인자들 전부를 모아서 배열로 받는 변수”
> 라고 이해하시면 됩니다.

---

## 4. 구조 분해 할당에서의 Rest 패턴 🎁

Rest는 함수 파라미터뿐만 아니라 **구조 분해 할당에서도 사용**됩니다.

### 4-1. 배열 구조 분해 + Rest

```js
const arr = [1, 2, 3, 4];

const [first, ...rest] = arr;

console.log(first); // 1
console.log(rest);  // [2, 3, 4]
```

### 4-2. 객체 구조 분해 + Rest

```js
const user = { id: 1, name: "Kim", age: 30 };

const { id, ...info } = user;

console.log(id);   // 1
console.log(info); // { name: "Kim", age: 30 }
```

여기서도 Rest는 항상 **마지막에만** 올 수 있습니다.

```js
const { ...info, id } = user; // ❌ 문법 에러
```

---

## 5. Spread vs Rest — 모양은 같고, 역할은 정반대 🤹‍♂️

이제 핵심 비교를 해보겠습니다.

### 5-1. 공통점

* 둘 다 **`...`** 문법을 사용한다.
* 모두 **배열/객체/값 리스트**와 함께 사용된다.

### 5-2. 차이점 (중요!)

| 구분     | Spread                                | Rest                               |
| ------ | ------------------------------------- | ---------------------------------- |
| 역할     | 펼친다 (expand)                          | 모은다 (collect)                      |
| 위치(주로) | **= 오른쪽(RHS)** / 함수 호출 인자 / 배열·객체 리터럴 | **= 왼쪽(LHS)** / 함수 파라미터 / 구조 분해 할당 |
| 결과 타입  | 여러 개의 값(요소 목록)                        | 하나의 배열 (Rest 파라미터/패턴)              |

---

### 5-3. 위치로 구분하는 방법 🧭

```js
// 1) Spread 예시
const arr2 = [0, ...arr1, 4];    // 배열 리터럴 안 → Spread
sum(...nums);                    // 함수 호출 인자 → Spread
const obj2 = { ...obj1, x: 1 };  // 객체 리터럴 안 → Spread

// 2) Rest 예시
function fn(...args) {}          // 함수 파라미터 → Rest
const [head, ...tail] = list;    // 배열 구조 분해 → Rest
const { id, ...rest } = user;    // 객체 구조 분해 → Rest
```

👉 **오른쪽에서 펼치면 Spread, 왼쪽에서 모으면 Rest** 라고 보면 직관적입니다.

---

## 6. 실전에서 어떻게 쓰이나? 💻

### 6-1. Spread + React props 전달

```jsx
const Button = (props) => <button {...props} />;

// 사용
<Button type="submit" className="primary" disabled />
```

`{...props}` →
props 객체를 펼쳐서 `<button>`에 `type=""`, `className=""`, `disabled` 같은 속성으로 전달.

---

### 6-2. Rest + React 컴포넌트 인자

```jsx
function Button({ label, ...rest }) {
  return <button {...rest}>{label}</button>;
}
```

* `label`만 따로 구조 분해
* 나머지 props는 `rest`로 모아서 그대로 `<button>`에 전달

---

### 6-3. Spread로 불변성 유지 (Immutable Update)

```js
const state = { count: 1, text: "hi" };

// count만 변경한 새 상태
const newState = { ...state, count: state.count + 1 };
```

기존 `state`를 직접 수정하지 않고 **새 객체를 만들 때** Spread가 자주 쓰입니다.

---

### 6-4. Rest로 가변 인자 함수 만들기

```js
function average(...nums) {
  const sum = nums.reduce((acc, n) => acc + n, 0);
  return nums.length ? sum / nums.length : 0;
}

average(1, 2, 3, 4); // 2.5
```

인자 개수가 고정되지 않은 함수에 매우 적합합니다.

---

## 7. 헷갈리기 쉬운 포인트 정리 ⚠️

### ✅ 7-1. Spread는 복사하지만, "깊은 복사"가 아니다

```js
const arr = [{ id: 1 }, { id: 2 }];
const copy = [...arr];

copy[0].id = 999;

console.log(arr[0].id); // 999 (같이 바뀜!)
```

→ 내부 요소(객체) 레퍼런스는 여전히 공유됩니다.

---

### ✅ 7-2. Rest는 함수 인자/구조 분해에서만 사용 가능

```js
const ...nums = [1, 2, 3]; // ❌ 문법 에러 (변수 선언 앞에 단독으로 X)
```

항상 **패턴 안에서** 사용해야 합니다.

---

### ✅ 7-3. Rest는 항상 마지막에만

```js
function fn(a, ...rest, b) {} // ❌
const [a, ...rest, b] = arr;  // ❌
```

---

## 8. 요약 📝

* `...`은 JavaScript에서 **두 가지 의미**를 가진다.
* **Spread 연산자**:

  * “펼쳐라”
  * 배열/객체/이터러블을 낱개로 펼쳐서 함수 인자, 배열/객체 리터럴에 사용
* **Rest 파라미터/패턴**:

  * “모아라”
  * 여러 개의 인자/프로퍼티를 **하나의 배열/객체로 모을 때** 사용
* 차이는 **위치(왼쪽 vs 오른쪽)** 와 **역할(펼침 vs 수집)** 으로 기억하면 된다.

```js
// Spread (펼쳐서 집어넣기)
sum(...nums);
const arr2 = [...arr1, 4];
const obj2 = { ...obj1, x: 1 };

// Rest (남은 것들 모으기)
function fn(a, ...rest) {}
const [head, ...tail] = arr;
const { id, ...restObj } = obj;
```


