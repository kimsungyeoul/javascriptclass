# 🔥 핵심 1: “호이스팅 = 변수 이름을 미리 알고 있다” 이거 딱 1줄임

자바스크립트 엔진이 코드를 실행하기 전에 이렇게 함:

```
아! 이 스코프 안에 b라는 변수가 있구나!
```

이게 **호이스팅**입니다.

* 코드가 위로 올라가는 게 아님
* 변수 선언을 미리 스캔해서 "이름"만 저장하는 거임

딱 이거임. 끝.

---

# 🔥 핵심 2: 그럼 아래 코드에서 무슨 일이냐?

```js
console.log(b);
let b = 20;
```

엔진은 실행 전에 다음처럼 기록함:

```
b 라는 변수가 있음.  
근데 아직 쓸 수 없음.
```

**"이름을 알고 있다" → 호이스팅 O** <br>
**"아직 쓸 수 없다" → 초기화 X → TDZ**

---

# 🔥 핵심 3: let이 초기화되기 전에는 접근 자체가 금지

엔진 내부 상태:

```
b = <uninitialized>   // 선언됨 (호이스팅)
```

이 상태에서 b를 쓰면 → 엔진이 이렇게 말함:

```
어? b가 있긴 한데 아직 준비가 안 됐어. (초기화 안 됨)
```

그래서 ReferenceError가 남.

---

# 🔥 핵심 4: 그럼 let이 진짜 “호이스팅이 안 되는 거”라면?

이 코드는

```js
console.log(b);
let b = 20;
```

만약 let이 진짜 호이스팅이 안 되는 거라면
엔진은 아예 **b라는 변수를 모르는 상태여야 합니다.**

그럼 에러 메시지는 이렇게 나와야 맞음:

```
ReferenceError: b is not defined
```

근데 실제 에러 메시지는 이렇게 나옵니다:

```
ReferenceError: Cannot access 'b' before initialization
```

즉,

* b가 있다는 것은 알고 있다 → **호이스팅됨**
* 하지만 초기화 전이라 접근 불가 → **TDZ 때문에 에러**

---

# 🔥 핵심 요약 (진짜 딱 2줄로 끝냄)

### ✔ 호이스팅 = 엔진이 변수 이름을 “선언문 전에 미리 알고 있는 것”

### ✔ let/const는 호이스팅됨. 하지만 초기화가 지연되어 "사용 금지 구역(TDZ)"가 생김.

그래서

```js
console.log(b); // b는 존재하지만 아직 준비 전 → ReferenceError
let b = 20;
```

이런 결과가 나오는 것.

---

# 🔥 더 단순하게 말해줄게 (진짜 끝판왕 요약)

* **var**
  → “이름도 알고 값도 undefined로 미리 만들어 둠”

* **let/const**
  → “이름은 미리 알지만 값은 나중에 넣을게. 그 전까지 건들지 마.”

그래서 var는 undefined가 나오고
let은 ReferenceError가 나오는 것.

