콜 스택(Call Stack)은 자바스크립트 엔진의 **심장부**입니다 ❤️
이걸 깊이 이해하면:

* 스코프/클로저/this
* 비동기(이벤트 루프)
* 에러 스택, 디버깅
* 재귀/스택 오버플로우

전부 “아, 그래서 이렇게 되는구나…” 하고 한 번에 정리됩니다.


---

## 1. 콜 스택이란? (정확한 정의부터) 🧱

**콜 스택(Call Stack)** = **현재 실행 중이거나, 실행 대기 중인 함수들의 “실행 컨텍스트(Execution Context)”를 쌓아두는 스택(LIFO) 구조**

* **스택(Stack)**: 후입선출(LIFO, Last-In First-Out)
* **원소**: 함수 1개당 → “실행 컨텍스트” 1개
* **위치**: 자바스크립트 엔진 내부(V8 등)의 런타임 구조 중 하나

> 자바스크립트는 **싱글 스레드**이므로, **콜 스택도 하나**입니다.
> “지금 이 순간 엔진이 정확히 *어디까지* 실행했는지”를 표현하는 구조가 콜 스택입니다.

---

## 2. “실행 컨텍스트”가 뭔데요? 🧩

콜 스택에는 “함수 이름” 같은 게 직접 쌓이는 게 아니라,
**그 함수를 실행하기 위해 필요한 모든 환경 정보**가 들어 있는 **실행 컨텍스트(Execution Context)**가 쌓입니다.

ECMAScript 기준으로 실행 컨텍스트는 개념적으로 이런 것들을 포함합니다:

* **Lexical Environment**

  * 현재 스코프에 있는 변수/함수 선언
  * 외부 스코프에 대한 참조(Outer Lexical Environment Reference)
* **Variable Environment**

  * `var` 선언 변수들 (초기 스펙에서는 별도로 구분했지만, 실제 구현에서는 통합되는 경우 많음)
* **ThisBinding**

  * 이 컨텍스트에서 `this`가 무엇을 가리키는지
* **Function / Script 정보**

  * 어떤 함수인지, 어떤 코드 블록인지
* **Generator / Async 상태(해당 시)**

  * `async function`, `generator function`의 중단/재개 지점 등

즉, 실행 컨텍스트 =

> “이 함수 안에서 쓰이는 변수, 스코프, this, 코드 상태 등 **실행에 필요한 모든 정보**의 패키지”

이 패키지들이 쌓여 있는 탑이 콜 스택입니다.

---

## 3. 콜 스택의 생성/변화 과정 (실행 라이프사이클) 🔄

### 3-1. 자바스크립트 프로그램 시작 시

1. **Global Execution Context** 생성
2. 콜 스택에 `Global Context` 푸시
3. 전역 코드 평가/실행 시작

```javascript
// 1. 전역 실행 컨텍스트 생성
// 2. Call Stack: [ Global ]

function foo() {}
function bar() {}
// 전역 코드 계속 실행...
```

콜 스택 상태:

```text
[ Top ] --> Global Execution Context
```

### 3-2. 함수 호출 시 (push)

```javascript
function a() {
  console.log("in a");
  b();
}

function b() {
  console.log("in b");
}

a();
```

실행 흐름 & 콜 스택 변화:

1. 처음: `Global`만 존재

   ```text
   [Top] Global
   ```

2. `a()` 호출 → `a`에 대한 실행 컨텍스트 생성 → 스택에 푸시

   ```text
   [Top] a()
          Global
   ```

3. `a` 내부에서 `b()` 호출

   ```text
   [Top] b()
          a()
          Global
   ```

4. `b`의 코드 실행 완료 → `b` 컨텍스트 팝(pop)

   ```text
   [Top] a()
          Global
   ```

5. `a`도 끝 → 팝

   ```text
   [Top] Global
   ```

6. 전역 코드까지 모두 종료 → `Global`도 팝
   (브라우저 환경에서는 곧바로 프로세스 종료는 아니지만, 실행 관점에서는 끝)

---

## 4. 콜 스택과 “런 투 컴플리션(Run-to-completion)” 규칙 ⚖️

자바스크립트의 아주 중요한 규칙:

> **하나의 실행 컨텍스트가 시작되면, 콜 스택이 비워질 때까지 어떤 다른 코드도 끼어들 수 없다.**

* 한 번 함수가 실행되기 시작하면 → 완전히 끝날 때까지 **동기적으로** 진행
* 실행 도중에 `setTimeout`, `Promise.then` 등을 호출해도
  → 콜백은 **나중에** 콜 스택이 비었을 때 들어온다.

이 규칙 때문에:

* JS는 스레드 동기화(락, 뮤텍스 등)를 안 써도 됨
* 대신, **무거운 연산(while 무한 루프, 대규모 연산)을 콜 스택에 오래 붙들어 두면 브라우저가 멈춤**

---

## 5. 콜 스택 vs Web API vs 큐 (역할 분리) 🧵

콜 스택은 **오직 JS 코드 실행만 담당**합니다.

### 예시:

```javascript
console.log("start");

setTimeout(() => {
  console.log("timeout");
}, 0);

console.log("end");
```

실제 동작:

1. `console.log("start")` → Global → 콜 스택에서 실행
2. `setTimeout(...)` 호출

   * 콜 스택에서는 `setTimeout` 함수 실행만
   * 타이머 설정/관리 자체는 **브라우저 Web API 스레드**에서 수행
3. `console.log("end")` 실행
4. Global 코드 끝 → 콜 스택 비게 됨
5. 타이머가 끝나면 → 콜백을 Task Queue에 넣음
6. **이벤트 루프**가 콜 스택이 빈 것을 보고 → 큐에서 콜백을 꺼내어 콜 스택에 푸시
7. 콜 스택에서 콜백 함수 실행 → `"timeout"` 출력

중요한 점:

> 콜 스택은 “비동기 작업을 기다리지 않는다”.
> **비동기 작업의 결과는 나중에 콜 스택에 “다시 호출”되는 것처럼 들어온다.**

---

## 6. 콜 스택과 에러, 스택 트레이스 🧨

에러가 발생할 때 우리가 보는:

```text
TypeError: x is not a function
    at baz (main.js:10)
    at bar (main.js:6)
    at foo (main.js:2)
    at main.js:15
```

이게 바로 **“콜 스택의 스냅샷”**입니다.

* “현재 예외가 발생한 위치부터, 그 함수를 호출한 상위 컨텍스트까지 역순으로 나열”
* 콜 스택이 LIFO 구조이기 때문에, **가장 위에 있는 함수부터 역추적** 형식으로 찍힘

디버깅 시:

* 브라우저 DevTools의 “Call Stack” 패널 = 엔진의 콜 스택 상태를 시각화한 것
* 브레이크포인트 걸린 지점에서:

  * 위쪽: 현재 함수
  * 아래쪽: 이 함수를 호출한 상위 함수들

---

## 7. 콜 스택과 재귀, 스택 오버플로우 🧱💥

콜 스택은 크기가 **유한**합니다. (엔진/플랫폼마다 다르지만 수천 ~ 수만 프레임 정도)

```javascript
function recurse(n) {
  return recurse(n + 1);
}
recurse(0);
```

이런 코드는 결국:

* 실행 컨텍스트가 계속 푸시되고
* 팝(pop)되는 시점 없이 무한히 증가 → 콜 스택 메모리 한도 초과

→ 대표 에러:

```text
RangeError: Maximum call stack size exceeded
```

**재귀 함수를 사용하면 항상 “언제 콜 스택에서 빠져나오는가?”를 고려해야** 합니다.

---

## 8. 콜 스택 vs 힙(Heap) – 메모리 관점에서 📦

실제 엔진 구현(예: V8)에서:

* **콜 스택(Stack)**:

  * 실행 컨텍스트 / 프레임, 각종 임시 값, 원시 타입(primitive) 등
  * 빠르고, 크기가 제한적
* **힙(Heap)**:

  * 객체(Object), 함수, 클로저, 배열 등
  * 동적으로 할당되고, GC(가비지 컬렉션)의 대상

중요한 점:

> 함수가 콜 스택에서 빠져나가도(컨텍스트 팝),
> **힙에 남아 있는 객체/클로저는 살아 있을 수 있다.**

→ 이게 바로 **클로저가 동작하는 원리**입니다.

---

## 9. 콜 스택과 클로저, 스코프 체인 🧬

클로저는:

> “이미 종료된 외부 함수의 변수에, 내부 함수가 계속 접근할 수 있는 현상”

이라고 배웁니다. 이게 콜 스택/힙/렉시컬 환경과 결합된 결과입니다.

```javascript
function outer() {
  const x = 10;
  function inner() {
    console.log(x);
  }
  return inner;
}

const fn = outer(); // outer의 실행 컨텍스트는 콜 스택에서 제거
fn();               // 하지만 x는 여전히 접근 가능
```

동작 구조:

1. `outer` 실행 → 실행 컨텍스트 생성 → 콜 스택 푸시
2. `x`, `inner`가 **outer의 Lexical Environment**에 저장
3. `outer`가 `inner`를 반환 → `inner` 함수 객체는 힙에 존재
4. `outer` 실행 끝 → 컨텍스트는 콜 스택에서 제거되지만

   * `inner` 함수 객체가 `outer`의 렉시컬 환경을 **참조**하고 있으므로 그 환경은 GC 되지 않음
5. `fn()` 호출 → 새로운 실행 컨텍스트가 콜 스택에 올라가지만

   * `x`는 힙에 남아 있는 “외부 렉시컬 환경”을 통해 읽힘

핵심:

> 콜 스택에서 컨텍스트가 빠져나가도,
> **렌시컬 환경(스코프 정보)은 힙에 살아남을 수 있다.**
> 콜 스택은 “현재 실행 중인 컨텍스트”만 관리할 뿐이다.

---

## 10. 동기/비동기 콜 스택 – “끊긴 스택” 문제 🧵

동기 호출에서 콜 스택은 “연속적”입니다.

```javascript
function a() { b(); }
function b() { c(); }
function c() { throw new Error("oops"); }

a();
```

에러 스택:

```text
Error: oops
  at c
  at b
  at a
  at <global>
```

하지만 비동기에서는?

```javascript
function a() {
  setTimeout(() => {
    b();
  }, 0);
}

function b() {
  c();
}

function c() {
  throw new Error("oops");
}

a();
```

이 경우:

* `a`가 끝날 때 콜 스택은 비워짐
* 나중에 타이머 콜백이 들어올 때 → 그건 **새로운 호출 체인**으로 간주
* 그래서 에러 스택에는 `a`가 안 보이기도 함 (엔진/환경마다 다름)

그래서 Node나 최신 브라우저에서는 **async stack traces** 같은 기능으로
비동기 호출도 “논리적으로 연결된 스택”처럼 보여주려고 노력합니다.

---

## 11. “콜 스택 깊이”를 의식해야 하는 패턴들 ⚠️

### 11-1. 재귀 알고리즘

* 트리/그래프 탐색 시 재귀 사용 → 깊이 큰 데이터에서 스택 오버플로우 위험
* JS에서는 **꼭 반복문 + 수동 스택 구조로 바꾸는 방법**도 고려

### 11-2. “동기적으로 무한히 이어지는” 코드

```javascript
function loop() {
  return loop();
}
```

또는

```javascript
function next() {
  // 약간씩만 일을 하고 있다고 해도
  doSomethingSync();
  next(); // 비동기 안 쓰고 계속 자기 자신 호출
}
```

이런 패턴은 **이벤트 루프에 제어권을 넘기지 않기 때문에** 전체 앱이 멈춥니다.

---

## 12. 요약: 콜 스택을 한 줄로 설명하면… ✅

> **콜 스택은 자바스크립트 엔진이 “지금 무엇을 실행 중인지”를 나타내는 실행 컨텍스트의 스택이며,**
> **이 스택이 비어야만 이벤트 루프가 큐에서 새로운 작업을 가져와 실행할 수 있다.**


어떤 방향으로 더 파보고 싶으신지 말씀해주시면, 그걸 기준으로 다음 레벨로 같이 들어가 보겠습니다 😄
