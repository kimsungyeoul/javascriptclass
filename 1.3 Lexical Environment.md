**Lexical Environment(렉시컬 환경)** 은 자바스크립트 실행 원리를 이해하는 데 가장 중요한 개념 중 하나입니다.
TDZ, 호이스팅, 스코프 행동, 클로저 모두 이 Lexical Environment로 설명됩니다.


---

# ✅ 1. Lexical Environment이란?

> **스코프에 어떤 변수·함수·파라미터들이 존재하는지 기록하고 관리하는 내부 메모리 구조**

쉽게 말하면,

* **이 스코프 안에 어떤 이름이 있는지**
* **그 이름에 어떤 값이 연결돼 있는지**
* **상위 스코프는 어디인지**

이 정보를 모두 가지고 있는 “환경 정보 객체”입니다.

즉, **스코프 = Lexical Environment**라고 봐도 됩니다.

---

# 🔥 2. Lexical Environment는 두 가지로 구성됨

Lexical Environment는 내부적으로 아래 두 컴포넌트로 구성됩니다.

## ✔ (1) Environment Record

> **변수·상수·함수 이름을 실제로 저장하는 공간**

예:

```js
let a = 10;
function f() {}
```

Environment Record 내부:

| 이름 | 값            |
| -- | ------------ |
| a  | 10           |
| f  | function(){} |

---

## ✔ (2) Outer Environment Reference

> **현재 스코프가 끝나면 어디를 찾아가야 하는가?**
> 즉, **상위 스코프를 가리키는 포인터**

이걸 통해 **스코프 체인(Scope Chain)** 이 만들어집니다.

예:

```js
function outer() {
  let x = 1;

  function inner() {
    let y = 2;
    console.log(x); // x를 찾기 위해 outer의 Lexical Environment로 이동
  }
}
```

`inner`의 Lexical Environment는 `outer`의 Lexical Environment를 **Outer**로 가리킴 → 그래서 `inner`에서도 `x` 접근 가능 → **클로저가 성립**.

---

# ✅ 3. Lexical Environment는 언제 만들어지나?

자바스크립트는 코드를 실행할 때 다음 단계를 거칩니다.

### 1) 실행 컨텍스트 생성

### 2) 그 안에 Lexical Environment 구성

### 3) 생성 단계 (변수 등록)

### 4) 실행 단계 (실제 코드 실행)

즉, Lexical Environment는 **스코프가 생길 때마다 자동 생성됩니다**.

생기는 타이밍은 아래와 같습니다:

* **전역 스코프**가 시작될 때
* **함수 실행** 시마다
* **블록 `{}` 진입 시마다** (let/const 때문에 ES6부터 생김)

---

# 🔥 4. Hoisting과 TDZ가 Lexical Environment에서 일어나는 일

Lexical Environment가 바로 **호이스팅(hoisting)과 TDZ(Temporal Dead Zone)** 를 담당합니다.

### ✔ var

* Environment Record에 등록됨
* **“초기화(undefined)”까지 즉시 진행**됨
  → 그래서 “undefined” 출력 가능
  → TDZ 없음

### ✔ let / const

* Environment Record에 등록됨
* **초기화는 선언문에 도달했을 때 수행**
* 초기화 전에 접근 시 → TDZ → ReferenceError

### ✔ function 선언문

* Environment Record에 **본문까지 모두 즉시 저장됨**
* 그래서 어디서든 호출 가능

---

# ✅ 5. 코드 예제로 Lexical Environment 살펴보기

### 코드:

```js
function test() {
  let a = 1;
  const b = 2;

  function inner() {
    let c = 3;
    console.log(a);
  }

  inner();
}
```

### Lexical Environment 구조 (시각화)

#### ✔ test 함수 실행 시:

```
test Lexical Environment
────────────────────────────────
Environment Record:
  a → 1
  b → 2
  inner → function

Outer: Global Environment
```

#### ✔ inner 함수 실행 시:

```
inner Lexical Environment
────────────────────────────────
Environment Record:
  c → 3

Outer: test Lexical Environment
```

inner에서 `console.log(a)` 실행 시:

1. 현재 스코프(inner) 확인 → `a` 없음
2. Outer(test 스코프)로 이동 → `a` 찾음
3. → 1 출력

이것이 **스코프 체인**이며, 이 체인은 **Lexical Environment**로 이루어져 있음.

---

# 🔥 6. Lexical Environment = 클로저(Closure)의 핵심

클로저가 가능한 이유도 Lexical Environment 덕분입니다.

```js
function outer() {
  let x = 10;
  return function inner() {
    console.log(x);
  }
}

const fn = outer();
fn(); // 10
```

`outer` 실행이 끝나도,

> inner의 Lexical Environment는 outer의 Environment를 계속 가리킴

그래서 outer의 변수 `x`가 살아있음 → 즉, **클로저**가 됨.

---

# ✔ 최종 정리

Lexical Environment란…

> **현재 스코프 안의 변수/함수 이름과 값, 그리고 상위 스코프를 기록하는 내부 메모리 구조**

그리고 이것이 담당하는 역할:

* 스코프 생성
* 호이스팅
* TDZ
* 스코프 체인
* 클로저

**이 모든 동작을 제어하는 핵심 엔진 구조가 바로 Lexical Environment입니다.**


