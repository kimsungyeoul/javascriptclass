# ✅ **TDZ도 var의 개떡같은 설계를 고치기 위해 만들어진 ‘안전장치’다.**

호이스팅이 JS 엔진 구조 때문에 생긴 “부작용”이었다면,
TDZ는 그 부작용을 **억제하기 위해 나중에 일부러 추가된 장치**입니다.

---

# 🔥 1. var 때문에 벌어진 개판을 때려잡기 위해 TDZ가 도입됨

var의 문제점:

1. **undefined로 초기화됨 → 선언 전 접근해도 undefined**
2. **버그가 숨어버림 → 디버깅 악몽**
3. **블록 스코프 없음 → 값이 새 나감**
4. **중복 선언 가능 → 실수해도 조용히 죽음**
5. **의도치 않은 전역 변수 생성 등 수많은 함정**

JS 창시자도 인정한 문제들임.

그래서 ES6(2015)에서 var를 고치는 대신:

* let
* const

새로운 선언 방식을 만들었음.

그런데…
let/const도 JS 엔진 구조상 **호이스팅을 막을 수는 없음**.

→ 그래서 “선언은 스코프에 등록해야 하지만, var 같은 개판은 못 나오게 해야 함”

이 딜레마 해결책이 바로:

# 💡 TDZ(Temporal Dead Zone)

---

# 🔥 2. TDZ의 진짜 목적 (아주 명확하게)

### ✔ **선언 전에 변수 접근 → 즉시 에러**

(var처럼 undefined를 뱉지 않게)

### ✔ **초기화 전까지 변수 사용 금지**

(안전성 확보)

### ✔ **정적 언어(Java, C, Python 등)처럼 동작하게 만들기**

---

# 🔥 3. TDZ가 없었다면 let/const는 var처럼 망했음

만약 TDZ가 없다면?

```js
console.log(a); 
let a = 10;
```

여기서 let도 호이스팅되므로

* 선언됨
* 초기화가 안 되어있지만…

TDZ가 없으면 var처럼 **undefined**가 나와버릴 것.

그러면 let도 var처럼 버그를 숨기기 시작함.

→ **TDZ가 없으면 let/const는 존재 의미가 사라짐**

---

# 🔥 4. TDZ의 역할은 정확히 이 한 문장임

> **“스코프에 등록은 되어 있지만 아직 초기화되지 않은 변수에 접근하면 죽여버리는 안전구역”**

그 구역이 바로 TDZ.

그냥:

* **등록됨**
* **하지만 잠겨있음**
* **선언문에 도달하면 잠금 해제**

이게 TDZ.

---

# 🔥 5. TDZ도 var 때문에 생긴 게 맞다

정확하게 단계 정리:

### 1) var의 개떡같은 구조 때문에

* undefined 초기화
* 선언 전 접근
* 버그 폭탄

### 2) let/const로 var를 대체하려고 했지만

* 호이스팅 자체는 엔진 구조상 없앨 수 없음

### 3) 그래서 선언 전 접근을 금지하는 “잠김 구역”을 넣음

→ **TDZ**

즉:

# ✔ TDZ = var의 부작용을 막기 위해 만들어진 보완 장치

# ✔ let/const가 현대 언어처럼 동작하게 만들기 위해 도입됨

---

# 🎯 최종 1문장 요약

> **호이스팅은 JS 초기 설계의 부작용이고, TDZ는 그 부작용의 피해를 막기 위해 ES6에서 추가된 안전장치다.**


