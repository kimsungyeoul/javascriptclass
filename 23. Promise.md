자바스크립트의 **Promise**는 “비동기 연산의 결과를 나타내는 값의 껍데기” 입니다.<br>
즉:

> **“아직 끝나지 않은 비동기 작업의 최종 성공/실패 상태와 그 결과값을 표현하는 상태 머신 + 콜백 등록기”**

라고 할 수 있습니다.


## 1. 왜 Promise가 등장했는가? (Callback Hell 탈출기) 🔥

### 1-1. 콜백 기반 비동기의 문제

이전에는 비동기 작업을 이렇게 했습니다:

```js
readFile("a.txt", function (err, dataA) {
  if (err) { 
    console.error(err);
    return;
  }
  readFile("b.txt", function (err, dataB) {
    if (err) {
      console.error(err);
      return;
    }
    readFile("c.txt", function (err, dataC) {
      if (err) {
        console.error(err);
        return;
      }
      console.log("모든 파일 읽기 완료");
    });
  });
});
```

문제점:

* **중첩 지옥 (Callback Hell)** : 들여쓰기가 깊어짐
* **에러 처리 중복** : 매번 `if (err)` 작성
* **흐름 추론이 어려움** : 성공/실패 흐름이 뒤엉킴
* **구성 가능성 낮음** : 비동기 결과를 다른 연산과 깔끔하게 조합하기가 어려움

### 1-2. Promise의 목표 🎯

Promise는 다음을 목표로 합니다.

1. **비동기 흐름을 “값”처럼 다룰 수 있게 한다.**
2. **성공/실패** 를 일관된 방식으로 처수



**executor 함수**는 즉시 실행되며, 두 개의 아규먼트를 받습니다.<br>
> 자바스크립트 엔진은 내부적으로 두 개의 특별한 함수(resolve, reject)를 생성하여 우리가 작성한 executor 함수의 아규먼트로 전달합니다.

```
// executor 함수
(resolve, reject) => {
  // executor 함수
  // 비동기 작업을 여기서 수행
}
```

* `resolve(value)` : 작업 성공 시 호출
* `reject(reason)` : 작업 실패 시 호출

### 3-2. 예시: setTimeout을 Promise로 감싸기

```js
function delay(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(`✅ ${ms}ms 후에 완료`);
    }, ms);
  });
}

delay(1000).then(message => {
  console.log(message); // "✅ 1000ms 후에 완료"
});
```

여기서 `delay(1000)`은 **“미래에 문자열을 제공할 Promise 객체”** 입니다.

---

## 4. then / catch / finally: 체이닝의 핵심 ⚙️

### 4-1. then의 역할

```js
promise.then(onFulfilled, onRejected);
```

* `onFulfilled(value)` : Promise가 `fulfilled`가 되었을 때 호출
* `onRejected(reason)` : Promise가 `rejected`가 되었을 때 호출 (선택적)

**가장 중요한 점**:
`then`은 **항상 새로운 Promise를 반환**합니다.

```js
const p2 = p1.then(value => {
  return value * 2;
});

// p2는 "value * 2" 결과를 담는 Promise
```

### 4-2. 체이닝의 예

```js
delay(500)
  .then(msg => {
    console.log(msg);
    return delay(500);
  })
  .then(msg2 => {
    console.log(msg2);
    return "모든 작업 완료";
  })
  .then(finalMsg => {
    console.log(finalMsg);
  });
```

흐름:

1. 첫 `delay(500)` 완료 → 첫 번째 `then`
2. 첫 번째 `then`에서 또 다른 Promise 반환 → 다음 `then`은 그 Promise 완료 후 실행
3. 마지막 `then`은 문자열 `"모든 작업 완료"`를 결과로 받음

### 4-3. 에러 처리: catch

```js
doAsync()
  .then(result => {
    throw new Error("문제 발생!");
  })
  .then(() => {
    // 이 then은 실행되지 않음
  })
  .catch(err => {
    console.error("에러 잡힘:", err.message);
  });
```

Promise의 특징:

* `then` 안에서 에러를 던지면 (`throw`), 해당 Promise는 자동으로 `rejected`가 됩니다.
* 그 이후 체인에서 **가장 가까운 `catch`**가 그 에러를 잡습니다.

### 4-4. finally: 성공/실패와 상관없이 실행

```js
doAsync()
  .then(result => {
    // ...
  })
  .catch(err => {
    // ...
  })
  .finally(() => {
    console.log("리소스 정리, 로딩 스피너 제거 등");
  });
```

* `finally`는 **결과를 바꾸지 않습니다.**
* 내부에서 return한 값은 무시되고, 이전의 성공/실패 상태가 그대로 다음으로 넘어갑니다.

---

## 5. 마이크로태스크 큐(Microtask Queue)와 Event Loop 🕒

Promise의 핵심은 **“언제 then이 실행되는가?”** 입니다.

### 5-1. 중요한 규칙

> `then`, `catch`, `finally` 콜백은 **항상 현재 실행 중인 동기 코드가 끝난 뒤**, **마이크로태스크 큐**에 의해 실행됩니다.

예:

```js
console.log("1");

Promise.resolve().then(() => {
  console.log("2");
});

console.log("3");
```

출력 순서:

```text
1
3
2
```

이유:

* `Promise.resolve().then(...)`는 **비동기 작업**으로 스케줄링됨
* 현재 콜스택의 동기 코드(`console.log("1")`, `console.log("3")`)가 끝난 후에야 `then` 콜백 실행

### 5-2. macrotask vs microtask

* **macrotask**: `setTimeout`, `setInterval`, I/O 이벤트 등
* **microtask**: `Promise.then`, `queueMicrotask`, MutationObserver 등

실행 우선순위는 일반적으로:

```text
1. 현재 콜스택 실행
2. microtask 큐 비움 (Promise then 등)
3. 다음 macrotask 실행 (setTimeout 등)
```

이것 때문에 **Promise 기반 비동기가 setTimeout보다 더 빨리 실행**되는 경우가 많습니다.

---

## 6. Promise 헬퍼 함수들: resolve / reject / all / race / allSettled / any 🧩

### 6-1. Promise.resolve / Promise.reject

```js
Promise.resolve(42).then(v => console.log(v)); // 42

Promise.reject(new Error("에러")).catch(err => console.log(err.message));
```

용도:

* **이미 있는 값을 Promise 형태로 감싸고 싶을 때**
* API가 Promise를 기대할 때, 값을 쉽게 감싸는 용도

### 6-2. Promise.all (병렬 실행 + 전체 성공 필요)

```js
const p1 = delay(1000).then(() => "A");
const p2 = delay(2000).then(() => "B");
const p3 = delay(1500).then(() => "C");

Promise.all([p1, p2, p3])
  .then(values => {
    console.log(values); // ["A", "B", "C"]
  })
  .catch(err => {
    console.error("하나라도 실패하면 여기로 옴", err);
  });
```

특징:

* **모든 Promise가 fulfilled** 되어야 `then` 실행
* 배열 중 하나라도 `rejected` 되면, **즉시** 전체가 `rejected`
* 결과는 **각 Promise의 결과를 같은 인덱스로 갖는 배열**

### 6-3. Promise.race (가장 먼저 끝나는 것)

```js
Promise.race([
  delay(1000).then(() => "빠른 작업"),
  delay(3000).then(() => "느린 작업"),
])
  .then(value => {
    console.log("승자:", value); // "빠른 작업"
  })
  .catch(err => {
    console.error("가장 먼저 실패한 Promise의 에러");
  });
```

특징:

* **가장 먼저 settle(성공 또는 실패)** 된 Promise의 결과를 그대로 전달

### 6-4. Promise.allSettled (모두 끝날 때까지 기다리기)

```js
Promise.allSettled([
  Promise.resolve(1),
  Promise.reject(new Error("fail")),
  Promise.resolve(3)
]).then(results => {
  console.log(results);
});
```

`results` 예:

```js
[
  { status: "fulfilled", value: 1 },
  { status: "rejected", reason: Error("fail") },
  { status: "fulfilled", value: 3 }
]
```

특징:

* 각 Promise의 **성공/실패 상태를 모두 보고 싶을 때** 사용
* 전체가 성공할 필요 없음

### 6-5. Promise.any (하나라도 성공하면 OK) ✨

```js
Promise.any([
  Promise.reject(new Error("fail 1")),
  Promise.reject(new Error("fail 2")),
  Promise.resolve("성공!")
]).then(value => {
  console.log("첫 성공:", value); // "성공!"
}).catch(aggErr => {
  console.log("전부 실패했을 때 AggregateError");
});
```

특징:

* **하나라도 fulfilled** 되면 그 값을 반환
* 모두 rejected 되면 **AggregateError** 발생

---

## 7. Thenable과 Promise Resolution Procedure 🔍

Promise는 “비슷하게 생긴 객체(thenable)”도 다룹니다.

```js
const thenable = {
  then(resolve, reject) {
    setTimeout(() => resolve("thenable에서 온 값"), 1000);
  }
};

Promise.resolve(thenable).then(v => {
  console.log(v); // "thenable에서 온 값"
});
```

**Promise Resolution Procedure** 규칙:

1. `Promise.resolve(x)`에서

   * `x`가 Promise면: 그 Promise를 그대로 “따라간다”.
   * `x`가 thenable이면: `x.then`을 호출하여 그 결과를 따름.
   * 그 외 값이면: 즉시 fulfilled Promise를 만든다.

이 메커니즘 덕분에 서로 다른 Promise 구현체 간도 **상호 운용성**이 유지됩니다.

---

## 8. async/await은 결국 Promise의 문법 설탕 🍬

`Promise`의 신태틱 슈가 코드로, 실제 현업에서는 거의 항상 `async/await`과 함께 쓰입니다.

```js
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function run() {
  console.log("start");
  await delay(1000); // Promise가 끝날 때까지 기다리지만, 스레드를 막지 않음
  console.log("1초 후");
}

run();
```

`async` 함수 특징:

* 항상 **Promise를 반환**합니다.
* `return 값` → `Promise.resolve(값)`으로 감싸짐
* `throw error` → `Promise.reject(error)`로 변환

`await`:

* 오른쪽 피연산자로 **Promise**를 기대합니다.
* 해당 Promise가 **fulfilled** 될 때까지 **그 함수 안의 흐름만** 잠시 멈추고, 값으로 풀어 줌
* `rejected` 되면 `try/catch`로 잡을 수 있음

```js
async function run() {
  try {
    const data = await fetchData();
    const processed = await processData(data);
    console.log(processed);
  } catch (err) {
    console.error("에러 발생:", err);
  }
}
```

이 모든 것도 결국 **Promise 체이닝 위에 얹힌 신태틱 슈가 코드**입니다.

---

## 9. 실전에서 자주 만나는 함정들 🧨

### 9-1. then 안에서 return을 빼먹는 경우

```js
// ❌ 잘못된 코드
doAsync()
  .then(result => {
    doAnotherAsync(result); // return 빠짐
  })
  .then(anotherResult => {
    // anotherResult는 undefined
  });
```

**올바른 코드:**

```js
doAsync()
  .then(result => {
    return doAnotherAsync(result); // 반드시 return
  })
  .then(anotherResult => {
    // 여기서 anotherResult 사용 가능
  });
```

→ `then` 내부에서 다음 비동기 작업의 Promise를 꼭 **return**해야 체인이 제대로 이어집니다.

### 9-2. new Promise로 “불필요하게” 감싸는 경우

```js
// ❌ 안티 패턴: 이미 Promise를 반환하는 함수를 다시 Promise로 감싸기
function bad() {
  return new Promise((resolve, reject) => {
    existingPromise().then(resolve).catch(reject);
  });
}
```

**올바른 패턴:**

```js
function good() {
  return existingPromise();
}
```

이미 Promise인 값을 굳이 한 번 더 래핑할 필요는 없습니다.

### 9-3. unhandledrejection (처리되지 않은 거부)

```js
new Promise((resolve, reject) => {
  reject(new Error("에러"));
});

// catch가 없음 → 브라우저에서 "Unhandled Promise Rejection" 경고
```

**해결**: 항상 `.catch()`를 마지막에 붙이거나, 상위에서 처리

```js
doAsync().catch(err => {
  console.error("전역 에러 처리:", err);
});
```

### 9-4. 동기/비동기 에러를 섞어서 혼동

```js
// 동기 에러
throw new Error("sync error");

// 비동기 에러 (Promise reject)
return Promise.reject(new Error("async error"));
```

* 동기 에러는 **즉시 try/catch**로 잡아야 하고
* 비동기 에러는 **Promise 체인에서 catch**로 잡아야 합니다.

---

## 10. 실전 패턴 정리 🧱

### 10-1. 콜백 스타일을 Promise로 래핑하기 (Promisify)

```js
function readFilePromise(path) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, "utf8", (err, data) => {
      if (err) reject(err);
      else resolve(data);
    });
  });
}
```

→ 이후엔 `await readFilePromise("a.txt")`로 깔끔하게 사용 가능

### 10-2. 여러 비동기 작업을 병렬로 실행하기

```js
async function loadPage() {
  const [user, posts, comments] = await Promise.all([
    fetchUser(),
    fetchPosts(),
    fetchComments()
  ]);
  // user, posts, comments를 동시에 로딩 후 한 번에 사용
}
```

* 순차적으로 `await` 하는 것보다 **훨씬 효율적**

### 10-3. 타임아웃 + 재시도 (간단한 예)

```js
function withTimeout(promise, ms) {
  const timeout = new Promise((_, reject) => {
    setTimeout(() => reject(new Error("Timeout")), ms);
  });
  return Promise.race([promise, timeout]);
}

withTimeout(fetchData(), 3000)
  .then(data => console.log(data))
  .catch(err => console.error("실패:", err.message));
```

이런 패턴은 Resilience4j로 하시는 것과 비슷한 **클라이언트 복원력 패턴**의 JS 버전이라고 보셔도 됩니다. 😉

---

## 11. 정리: Promise를 한 줄로 요약하면… ✅

> **“Promise는 비동기 연산을 일급 값으로 표현하는 상태 기반 객체로,
> 체이닝과 구성 가능성을 통해 콜백 지옥 없이 복잡한 비동기 흐름을 다루게 해주는 추상화”**

실무에서 Promise를 제대로 이해하면:

* `async/await`의 동작을 **머리 속에서 정확히 추론**할 수 있고
* **Race, Timeout, Retry, Fallback** 같은 복원력 패턴을 JS 레벨에서도 구현할 수 있으며
* Web, Node.js, React, Axios, fetch 등 거의 모든 현대 JS 비동기 API를 **정확히 다룰 수 있게** 됩니다.

