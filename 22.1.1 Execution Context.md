> **콜 스택(Call Stack)** 안에는 **“실행 컨텍스트(Execution Context)”라는 덩어리**들이 차곡차곡 쌓입니다.
> 이 **실행 컨텍스트 1개가 = 자바스크립트 엔진이 어떤 코드를 “어떤 환경에서” 실행 중인지에 대한 모든 정보를 담고 있는 스냅샷**입니다.

이제 하나씩 아주 정밀하게 파보겠습니다. 🙂

---

## 1. 큰 그림: 콜 스택과 실행 컨텍스트의 관계

* **콜 스택(Call Stack)**

  * “현재 어떤 코드가 실행 중인가”를 관리하는 **스택 구조의 메모리**
  * **맨 위(top)**에 있는 것이 **지금 실행 중인 실행 컨텍스트**

* **실행 컨텍스트(Execution Context)**

  * 특정 코드 조각(전역 코드, 함수 코드 등)을 실행하기 위해 **엔진이 만들어 놓는 “실행 환경” 정보 묶음**
  * 실행 컨텍스트 하나에는 예를 들어 이런 것들이 들어 있습니다:

    * 그 코드에서 사용할 **변수/함수/매개변수 정보**
    * **this가 무엇을 가리키는지**
    * **외부 스코프(어디까지 변수 찾아 올라갈지)** 정보
    * `var`/`let`/`const`가 어디까지 보이는지 등

🔁 **과정 요약**

1. 자바스크립트 파일을 실행 → **전역 실행 컨텍스트(Global EC)** 생성 → 콜 스택에 push
2. 함수 호출 → **새 실행 컨텍스트(Function EC)** 생성 → 콜 스택에 push
3. 그 함수가 끝나면 → 해당 컨텍스트를 콜 스택에서 pop
4. 항상 **스택 맨 위의 컨텍스트만** 실제로 실행 중

---

## 2. 실행 컨텍스트의 종류

표준 관점에서 보면 대표적으로:

1. **전역 실행 컨텍스트 (Global Execution Context)**

   * JS 코드가 로드되면 **딱 1개** 생성
   * `window`/`global` 같은 전역 객체와 연결
   * 전역 변수, 전역 함수들이 여기에 담김

2. **함수 실행 컨텍스트 (Function Execution Context)**

   * 함수가 호출될 때마다 **매번 새로 생성**
   * 매개변수, 내부 변수, 내부 함수, `arguments` 등이 여기에 담김

3. (참고) 모듈 실행 컨텍스트, eval 컨텍스트도 있지만, 개념 이해에는 **전역 + 함수**만 잡으면 충분합니다.

---

## 3. 실행 컨텍스트 내부 구조 (가장 핵심 파트)

ES 명세 스타일로 조금 더 공식적으로 표현하면,
**실행 컨텍스트는 대략 이런 필드들을 가진 객체라고 생각**할 수 있습니다:

* **LexicalEnvironment (어휘 환경, 렉시컬 환경)**
* **VariableEnvironment (변수 환경)**
* **ThisBinding (this가 무엇인지)**
* (그 외: Realm, ScriptOrModule 등… → 일반 개발자 관점에서 보통 생략)

이 중에서 우리가 가장 많이 신경 쓰는 건 세 가지입니다.

### 3.1 Lexical Environment (렉시컬 환경)

**스코프, TDZ, `let`/`const`, 클로저** 등이 전부 여기에서 결정됩니다.

렉시컬 환경은 내부적으로 이렇게 생겼다고 생각하면 됩니다:

```text
LexicalEnvironment = {
  EnvironmentRecord: { 실제로 변수/함수 바인딩이 저장되는 곳 },
  Outer: 바깥(부모) 렉시컬 환경에 대한 참조
}
```

* **EnvironmentRecord**

  * 현재 스코프 안에서 선언된 식별자들(변수 이름, 함수 이름 등)을 테이블처럼 저장
  * `let`, `const`, `class`, 함수 선언문, 매개변수 등이 여기에 바인딩 됨
  * `TDZ(Temporal Dead Zone)` 정보도 이 레벨에서 관리

* **Outer**

  * “밖으로 나가면 어디 스코프부터 다시 찾아볼까?”
  * 이게 바로 **스코프 체인(Scope Chain)** 의 연결 고리

### 3.2 Variable Environment (변수 환경)

* 초기 JS 엔진 / 명세 구조에서 **`var` 선언을 따로 관리**하기 위해 분리된 개념
* 실제로는 **LexicalEnvironment와 거의 비슷한 구조**를 갖습니다.
* 요약하자면:

  * `var`로 선언된 것들은 **VariableEnvironment 쪽**
  * `let` / `const`로 선언된 것들은 **LexicalEnvironment 쪽**
* 최신 엔진 구현에서는 두 환경을 합쳐서 최적화하는 경우도 있지만,
  **개념적으론 “var 전용 공간 vs let/const 전용 공간”** 정도로 이해하시면 됩니다.

👉 왜 이런 구조가 필요하냐? →

* `var`는 **함수 스코프 + 호이스팅 + 초기값 `undefined`**
* `let`/`const`는 **블록 스코프 + TDZ**
* 이 미묘한 차이를 **엔진이 다르게 처리하기 위해** 내부 저장소를 분리한 것이라고 보면 됩니다.

### 3.3 This Binding

* 해당 실행 컨텍스트 안에서 `this`가 무엇인지 저장하는 위치
* 예시:

  * 전역 컨텍스트: 브라우저에서는 일반적으로 `window`, Node.js에서는 `global` (strict 모드에선 `undefined`)
  * 메서드 호출: 그 메서드를 소유한 객체
  * `call/apply/bind`: 우리가 넘긴 첫 번째 인자
  * 클래스/생성자 호출: 새로 생성되는 인스턴스 객체

---

## 4. 실행 컨텍스트 생성 과정: “생성 단계”와 “실행 단계”

함수 하나가 호출될 때, 그 안에서 일이 **두 단계로 진행**된다고 생각하면 이해하기 좋습니다.

```js
function foo(a, b) {
  console.log(x); 
  var x = 10;
  let y = 20;
}
foo(1, 2);
```

### 4.1 1단계: 생성 단계 (Creation Phase)

함수가 호출되어 **실행 컨텍스트가 만들어질 때**:

1. **새 실행 컨텍스트 구조 만들기**

   * `LexicalEnvironment`, `VariableEnvironment`, `ThisBinding` 초기화
2. **this 바인딩 결정**

   * `foo`가 어떻게 호출되었는지에 따라 `this` 결정
3. **변수/함수 선언 수집**

   * 함수 매개변수, 함수 선언문, `var`, `let`, `const` 등을 쭉 훑어서

     * **이름들을 미리 렉시컬/변수 환경에 등록**
   * 이때 차이가 발생:

     * `var x`
       → 이름 `x`를 VariableEnvironment에 등록하고, **초기값을 바로 `undefined`로 셋팅**
       → 그래서 “호이스팅 시 값이 `undefined`”
     * `let y`
       → 이름 `y`를 LexicalEnvironment에 등록하되, **초기값 없이 “TDZ 상태”로만 등록**
       → 실제 초기화 이전에 접근하면 **ReferenceError**
     * 함수 선언문 `function bar() {}`
       → 전체 함수 객체를 해당 이름에 바로 대입
       → 따라서 선언문보다 위에서 호출해도 동작

### 4.2 2단계: 실행 단계 (Execution Phase)

이제 실제로 함수 본문을 위에서부터 실행하기 시작합니다.

* `console.log(x);`

  * 변수 조회: 현재 실행 컨텍스트의 환경에서 `x`를 찾음
  * 이미 생성 단계에서 `x = undefined`가 되어 있으므로 → `undefined` 출력
* `var x = 10;`

  * 이미 `x`라는 식별자는 존재
  * **할당문**이 실행되면서 값이 `10`으로 변경
* `let y = 20;`

  * 이 시점에 와서야 비로소 `y`가 **TDZ에서 벗어나고**, `20`으로 초기화

---

## 5. 콜 스택에 쌓이는 “실행 컨텍스트”의 모습

간단한 예제로 콜 스택과 실행 컨텍스트 흐름을 같이 보면 더 잘 보입니다.

```js
console.log('start');

function first() {
  const a = 1;
  second();
}

function second() {
  const b = 2;
  console.log('end');
}

first();
```

실행 흐름:

1. **전역 코드 시작**

   * 💾 **전역 실행 컨텍스트 생성 → 콜 스택에 push**
   * 전역 렉시컬/변수 환경에:

     * `first` 함수 선언
     * `second` 함수 선언
     * `console` 전역 객체 등 등록

2. `console.log('start')` 실행

   * 전역 컨텍스트 안에서 동작 (내부적으로는 `console.log` 호출 시 또 다른 실행 컨텍스트가 잠깐 생길 수 있지만, 개념 이해 상 생략)

3. `first()` 호출

   * 💾 **`first` 함수 실행 컨텍스트 생성 → 콜 스택에 push**
   * `first` 컨텍스트 안:

     * LexicalEnvironment: `a`, (내부 함수가 있다면 그 함수들)
     * ThisBinding: 호출 방식에 따라 결정 (여기서는 전역 this)

4. `const a = 1;` 실행

5. `second()` 호출

   * 💾 **`second` 함수 실행 컨텍스트 생성 → 콜 스택에 push**
   * `second` 컨텍스트 안:

     * LexicalEnvironment: `b`
     * ThisBinding: 동일하게 결정

6. `const b = 2;`, `console.log('end')` 실행

7. `second` 함수 종료

   * 콜 스택에서 **`second` 컨텍스트 pop**

8. `first` 함수 남은 코드 없음 → 종료

   * 콜 스택에서 **`first` 컨텍스트 pop**

9. 전역 코드도 다 실행되면

   * 필요 시 전역 컨텍스트는 가비지 컬렉션 대상이 되거나, 환경에 따라 계속 유지(브라우저 탭이 열려 있는 동안 등)

---

## 6. 실행 컨텍스트와 스코프 / 클로저의 관계

### 6.1 스코프 체인 = 렉시컬 환경의 연결

```js
let x = 1;

function outer() {
  let y = 2;
  function inner() {
    let z = 3;
    console.log(x, y, z);
  }
  inner();
}
outer();
```

* `inner()`의 실행 컨텍스트에서 `x`를 찾는 순서:

  1. `inner`의 LexicalEnvironment (→ `z`만 있음)
  2. Outer 참조 → `outer`의 LexicalEnvironment (→ `y` 있음)
  3. 다시 Outer → 전역 LexicalEnvironment (→ `x` 있음)

이 “찾아 올라가는 구조”가 바로 **스코프 체인**
→ 전부 **각 실행 컨텍스트가 가지고 있는 LexicalEnvironment의 `Outer` 연결** 덕분입니다.

### 6.2 클로저(Closure)와 실행 컨텍스트

```js
function makeCounter() {
  let count = 0;
  return function () {
    count++;
    console.log(count);
  };
}

const counter = makeCounter();
counter(); // 1
counter(); // 2
```

* `makeCounter()` 실행이 끝나면, 원래라면 그 실행 컨텍스트는 스택에서 pop.
* 하지만 **내부 함수(익명 함수)가 `count`에 접근하고 있기 때문에**,
  엔진은 `makeCounter`의 렉시컬 환경을 메모리에서 완전히 버리지 않습니다.
* 이렇게 **이미 종료된 실행 컨텍스트의 환경(LexicalEnvironment)이 살아 있는 현상**이 바로 **클로저**입니다.

> 정리하자면, 클로저는 **“이미 콜 스택에서는 사라졌지만, LexicalEnvironment가 어딘가에 계속 붙잡혀 있는 실행 컨텍스트의 흔적”**이라고 봐도 됩니다.

---

## 7. 실행 컨텍스트와 `var` / `let` / `const` 스코프 차이 (이전에 헷갈리셨던 부분 연결)

왜 `var`가 “함수 스코프”라고 하는지, 실행 컨텍스트 관점에서 정리해 보겠습니다.

```js
function test() {
  if (true) {
    var a = 10;
    let b = 20;
  }
  console.log(a); // 10
  console.log(b); // ReferenceError
}
test();
```

* `test` 함수 실행 컨텍스트 생성 시:

  * **VariableEnvironment (var 전용)**

    * `a`를 **함수 전체를 스코프로 하는 환경**에 등록
  * **LexicalEnvironment (let/const 전용)**

    * `if` 블록 내부 `{}`에 대해 **별도의 렉시컬 환경이 하나 더 생성**
    * 그 안에 `b`가 등록 (TDZ → 초기화 후 20)

따라서:

* `a`는 **함수 실행 컨텍스트 전체에서 접근** 가능 → `console.log(a)` OK
* `b`는 **if 블록 렉시컬 환경 안에서만 유효** → 블록을 벗어나면 찾을 수 없음 → ReferenceError

👉 즉,

* **“var는 함수 실행 컨텍스트 단위로 스코프를 가진다”**
* **“let/const는 블록(렌시컬 환경) 단위로 스코프를 가진다”**
  라는 말을 하는 것이고, 이 모든 것은 **실행 컨텍스트 내부의 환경 구조 차이** 때문에 발생하는 현상입니다.

---

## 8. 요약 정리

1. **실행 컨텍스트(Execution Context)**

   * JS 코드가 실행될 때 **“그 코드를 어떤 환경에서 실행할지”에 대한 묶음 정보**
   * 콜 스택의 각 “프레임”이 바로 실행 컨텍스트

2. **주요 구성 요소**

   * `LexicalEnvironment`: `let/const`, 함수, 블록 스코프, TDZ, 외부 스코프 참조(Outer)
   * `VariableEnvironment`: `var` 전용 저장소 (함수 스코프 + `undefined` 호이스팅)
   * `ThisBinding`: 해당 컨텍스트에서의 `this` 값

3. **생성 단계 vs 실행 단계**

   * 생성 단계: 스코프/환경 설정, 선언들 수집, `var` = `undefined`, `let/const` = TDZ
   * 실행 단계: 실제 코드 한 줄씩 실행, 할당/연산 수행

4. **콜 스택과의 관계**

   * 전역 → 함수 호출 → 또 다른 함수 호출 순으로 **실행 컨텍스트가 스택에 push/pop**
   * 스택 맨 위의 컨텍스트만 실제로 실행

5. **스코프/클로저의 근본 원인**

   * 모든 스코프/클로저 현상은 결국
     **실행 컨텍스트 안의 LexicalEnvironment들이 서로 연결된 구조**로 설명 가능


