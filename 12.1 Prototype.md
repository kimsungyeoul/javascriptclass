
# 🔥 자바스크립트 프로토타입(Prototypes)

*"JavaScript를 진짜 이해하고 싶다면 **프로토타입**을 반드시 알아야 한다!"*

자바스크립트는 **클래스 기반 언어가 아니라 프로토타입 기반 언어**입니다.
이 말은 곧 “객체는 또 다른 객체를 원형(Prototype)으로 삼아 동작한다”는 의미입니다.

---

# 1. 🧬 프로토타입이란 무엇인가?

## ✔️ 정의

자바스크립트에서 모든 객체는 **자신의 부모 역할을 하는 또 하나의 객체**를 가지고 있는데, 이것이 바로 **Prototype(프로토타입)** 입니다.

즉,

> 객체가 특정 프로퍼티를 찾을 수 없으면, 그 부모 객체(프로토타입)에게 물어보는 구조

이를 **프로토타입 체인(Prototype Chain)** 이라고 부릅니다.

📌 **핵심 포인트**

* 모든 객체는 내부 슬롯 `[[Prototype]]`을 가진다.
* 이 `[[Prototype]]`은 또 다른 객체다.
* 객체는 자신의 프로퍼티가 없으면 이 `[[Prototype]]`에서 찾는다.

---

# 2. 🔗 프로토타입 체인(Prototype Chain)

```js
const person = {
  isHuman: true
}

const me = {
  name: "성원"
}

Object.setPrototypeOf(me, person);

console.log(me.isHuman); // true
```

`me` 객체에는 `isHuman`이 없는데도 왜 `true`가 나올까?
→ `me` 객체의 프로토타입이 `person`이기 때문입니다.

📌 체인의 동작

1. `me.isHuman` 탐색
2. me 객체에 없음
3. me → [[Prototype]] → person 객체 탐색
4. `person.isHuman` 발견 → 반환

✔️ 이처럼 객체는 **필요할 때 상위 객체의 기능을 빌려 쓸 수 있는 구조**입니다.

---

# 3. 📦 함수와 프로토타입: `prototype` 프로퍼티

자바스크립트의 모든 **함수(Function)는 객체**이고, 여기에 자동으로 **`prototype` 프로퍼티가 붙습니다.**

```js
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function () {
  console.log("Hi!");
}

const p1 = new Person("sumi");
p1.sayHi(); // Hi!
```

### 왜 이런 구조가 필요할까? 🤔

`Person`으로 객체를 1만 개 생성할 경우,
모든 객체가 `sayHi` 함수를 개별 메모리에 가진다면 **메모리 낭비**가 엄청나다.

✔️ 그래서 공통 메서드는 `prototype`에 저장하고
✔️ 인스턴스(p1)는 필요할 때 prototype으로부터 메서드를 참조한다.

---

# 4. 🚀 new 키워드와 프로토타입 동작 과정

`new` 연산자가 객체를 생성할 때 실제로 어떤 일이 일어나는지 단계별로 보면 이해가 확실해집니다.

### `new Person("sumi")`가 내부적으로 실행되는 과정:

1. **새로운 빈 객체 생성** → `{}`
2. 그 객체의 `[[Prototype]]`을 `Person.prototype`으로 설정
3. Person 함수 실행 (this가 새 객체를 가리킴)
4. 완성된 객체를 반환

즉,

> new 키워드는 객체의 프로토타입을 자동으로 연결해주는 문법적 설탕(syntax sugar)

---

# 5. 🧱 객체 리터럴도 프로토타입을 가진다

```js
const user = { name: "kim" };

console.log(Object.getPrototypeOf(user));
```

출력 결과는?

👇

```
{ constructor: f Object(), __defineGetter__: ... , hasOwnProperty: ... }
```

이는 **Object.prototype** 이며, 모든 `{}` 객체는 이것을 기본 프로토타입으로 가진다.

✔️ 결론적으로,
객체 리터럴로 만든 객체조차도 프로토타입 체인 위에 존재한다.

---

# 6. ⚙️ 프로토타입을 활용하면 좋은 경우

### ✔️ 1. 동일한 메서드를 공유하고 싶을 때

ex) 동일한 종류의 객체가 동일한 행동을 가져야 할 때
→ 생성자 함수 + prototype 사용

### ✔️ 2. 성능 최적화

프로토타입 메서드는 **메모리를 공유**합니다.

### ✔️ 3. Class 문법도 결국 Prototype

ES6의 `class`는 내부적으로 prototype 기반으로 작동합니다.

```js
class Car {
  drive() {}
}
```

위 코드는 실제로는:

```js
function Car() {}
Car.prototype.drive = function() {}
```

와 동일합니다.

---

# 7. 🧠 프로토타입 vs 클래스 기반 언어 비교

| 구분     | 클래스 언어(Java/C# 등) | JavaScript 프로토타입   |
| ------ | ----------------- | ------------------ |
| 객체 생성  | class → instance  | prototype → object |
| 상속 구조  | 클래스 상속            | 프로토타입 체인           |
| 메서드 공유 | 클래스 내부 정의         | prototype에 정의      |
| 기반 철학  | 타입 기반             | 객체 기반              |

📌 JS는 “객체가 또 다른 객체를 상속하는 구조”라는 점에서 유연함이 매우 크다.

---

# 8. 🔥 프로토타입 체인 시각화

```
p1
 └── [[Prototype]] → Person.prototype
                            └── [[Prototype]] → Object.prototype
                                                         └── null
```

여기서 **Object.prototype의 프로토타입이 null**이라는 것은
JS 객체 체인의 최종 끝이란 뜻입니다.

---

# 9. ✨ 결론: 프로토타입은 JS 객체 시스템의 근본 철학이다

프로토타입을 이해하면 다음이 모두 선명하게 보입니다.

✔ 클래스 문법의 내부 구조
✔ 상속이 어떻게 동작하는지
✔ 메서드 공유 방식
✔ 엔진이 프로퍼티를 어떻게 탐색하는지
✔ React/Vue의 prototype 기반 메커니즘 일부

프로토타입을 알면 **자바스크립트의 본질을 이해하는 것과 같다**고 해도 과언이 아닙니다. 🚀

