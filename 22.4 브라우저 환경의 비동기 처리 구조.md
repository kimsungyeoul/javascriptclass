# 🌐 브라우저 비동기 처리

## — 콜 스택, Web API, 큐, 이벤트 루프의 정교한 협업 메커니즘

웹 브라우저 환경에서 자바스크립트가 어떻게 **동기/비동기 코드**를 협력적으로 처리하는지 이해하는 것은 프론트엔드 개발에 있어 필수적인 지식입니다.
**콜 스택(Call Stack)**, **Web API**, **Task/Microtask Queue**, **Event Loop**가 어떻게 하나의 유기적 시스템으로 동작하는지, 그 **운영 사이클 전체를 정확하고 깊게** 분석합니다.

---

# 🏗️ 1. 브라우저 비동기 아키텍처 전체 지도

브라우저 안에는 단순히 JS 엔진만 존재하지 않습니다. 여러 전문 컴포넌트들이 **협력 조직**을 이루고 있습니다.

| 구성 요소                              | 설명                                         |
| ---------------------------------- | ------------------------------------------ |
| **📌 콜 스택 (Call Stack)**           | 현재 실행 중인 JS 코드가 쌓이는 스택(싱글 스레드)             |
| **⚙️ Web API**                     | 타이머, DOM 이벤트, 네트워크 요청 등 비동기 작업을 백그라운드에서 처리 |
| **🧩 마이크로태스크 큐 (Microtask Queue)** | Promise then / await 이후 작업 등 **고우선순위** 큐   |
| **📬 태스크 큐 (Task Queue)**          | setTimeout, DOM 이벤트 콜백 등이 들어오는 일반 큐        |
| **🔄 이벤트 루프 (Event Loop)**         | 스택과 큐들을 지속적으로 감시하며 작업을 분배하는 컨트롤 타워         |

브라우저 세계에서 자바스크립트는 ‘싱글 스레드’이지만, 실제로는 위 구성 요소들이 팀 플레이를 통해 **멀티스레드처럼 느껴지는 비동기 환경**을 제공합니다.

---

# 🔁 2. 이벤트 루프의 6단계 사이클 (Event Loop Cycle)

이벤트 루프는 끊임없이 아래 사이클을 반복하며 브라우저 전체의 작업 흐름을 조율합니다.

---

## ▶️ **1단계 — 동기 코드 실행 (Call Stack)**

JS 엔진은 가장 먼저 동기 코드를 읽어 콜 스택에 올리고 실행합니다.

* 함수 호출 → 스택에 PUSH 후 실행
* 변수 선언 → 스택에서 처리
* `setTimeout`, `fetch` 호출 → Web API에 작업을 위임하고 스택에서 POP

즉, 비동기 작업은 콜 스택에서 즉시 빠져나가고 **백그라운드**로 이동합니다.

---

## ▶️ **2단계 — Web API 처리 (Background Task)**

Web API는 JS 엔진 밖에서 독립적으로 작업합니다.

* 타이머 → 시간 측정
* DOM 이벤트 → 이벤트 감지
* 네트워크 → 서버 응답 대기

👉 여기서 **얼마나 오래 걸리든** JS 콜 스택은 전혀 막히지 않습니다.

---

## ▶️ **3단계 — 큐잉 (Queueing)**

Web API가 작업을 마치면 **콜백을 해당 큐로 이동**시킵니다.

* **Promise** → ✔️ *마이크로태스크 큐*
* **setTimeout, DOM 이벤트** → 📬 *태스크 큐*

이 시점부터 이벤트 루프가 콜 스택이 빌 때까지 기다리게 됩니다.

---

## ▶️ **4단계 — 마이크로태스크 처리 (Microtasks First!)**

이벤트 루프는 콜 스택이 비면 바로 다음 순서를 따릅니다:

1. **마이크로태스크 큐 확인**
2. **모두 처리될 때까지 싹쓸이 실행**

즉, 마이크로태스크는 **단 한 개도 남지 않을 때까지** 실행됩니다.
Promise 내부에서 또 새로운 Promise를 생성하면 그것까지 처리합니다.

👉 이 특징 때문에 마이크로태스크는 “마이크로”가 아니라 사실상 **최강 우선순위 작업**입니다.

---

## ▶️ **5단계 — 렌더링 업데이트 (Render Opportunity)**

마이크로태스크가 비워진 순간, 브라우저는 렌더링(화면 갱신)을 진행할 기회를 가집니다.

* 보통 60fps → 1초에 60번 리렌더링 체크 기회
* 레이아웃, 페인트, 리플로우 등의 UI 업데이트가 여기서 수행됨

---

## ▶️ **6단계 — 태스크 큐 처리 (Task Queue)**

이제서야 일반 태스크 큐가 선택됩니다.

* 태스크 큐에서는 **한 번의 루프당 하나의 콜백만 실행**
* 실행 후 다시 1단계부터 사이클 반복

---

# 🧪 3. 실제 코드로 전체 흐름 이해하기

```javascript
console.log("Start");

setTimeout(() => console.log("Timeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");
```

실행 흐름을 단계별로 따라가면:

1️⃣ `Start` → 콜 스택
2️⃣ `setTimeout` → Web API → 태스크 큐
3️⃣ `Promise.then` → 마이크로태스크 큐
4️⃣ `End`
5️⃣ 콜 스택이 빔 → **마이크로태스크 실행 → "Promise" 출력**
6️⃣ 태스크 큐 실행 → `"Timeout"` 출력

📌 따라서 출력 순서는:

```
Start
End
Promise
Timeout
```

---

# 🧭 4. 최종 요약 — 전체 우선순위 구조

| 우선순위       | 구성 요소     | 설명                   |
| ---------- | --------- | -------------------- |
| 🔥 **0순위** | 콜 스택      | 동기 코드 즉시 실행          |
| ⚡ **1순위**  | 마이크로태스크 큐 | Promise / await 후 작업 |
| 🕗 **2순위** | 태스크 큐     | setTimeout, 이벤트 콜백   |

자바스크립트의 기본 원칙은 다음 한 문장으로 요약할 수 있습니다:

> **"동기는 무조건 먼저, 마이크로태스크는 모두 비운 후, 그 다음에 태스크를 처리한다."**

