# 🌐 Web API — 브라우저 비동기 환경의 핵심 엔진

많은 개발자가 **Web API = setTimeout / DOM API** 정도로 이해하지만, 이는 매우 피상적인 수준입니다.
**실제로 Web API는 브라우저가 제공하는 모든 백그라운드 비동기 기능**이며, JavaScript 엔진과는 완전히 별개의 시스템입니다.

즉,

> **Web API = 브라우저(Host Environment)가 제공하는 “비동기·입출력 기능을 담당하는 멀티 스레드 런타임”**

---

# 🧩 1. Web API는 어디에 있는가? (JavaScript 엔진과의 영역 분리)

브라우저는 다음과 같은 거대한 아키텍처로 구성됩니다:

```
  ─────────────────────────────
|         Browser               |
|  ┌───────────────────────┐    |
|  | JavaScript Engine     | ← 콜스택/힙만 담당!  
|  | (V8, SpiderMonkey…)   | ← 싱글 스레드!
|  └───────────────────────┘    |
|          ▲                    |
|          |                    |
|      Event Loop               |
|          |                    |
|   Web API Threads  ← 비동기 작업🔥 
|   (Timer, Network, IO, DOM…)  |
  ─────────────────────────────
```

✔ JavaScript 엔진(V8)은 **싱글 스레드**
✔ Web API 영역은 **멀티 스레드**
✔ 둘은 이벤트 루프(Event Loop)를 통해 데이터를 교환

자바스크립트는 원래 **브라우저가 제공하는 기능 없이 할 수 있는 일이 거의 없음**
(콘솔 출력, DOM 조작, 타이머, AJAX 모두 Web API)

---

# 🧵 2. Web API는 어떤 스레드로 이루어져 있는가?

브라우저는 다양한 목적을 가진 내부 스레드를 가집니다:

### ■ 💠 Timer Thread

* `setTimeout`, `setInterval`
* 지정된 시간이 지나면 콜백을 Task Queue로 보냄

### ■ 💠 Network Thread

* Fetch, XHR, WebSocket
* 네트워크 요청 수행 → 완료 후 콜백을 큐로 전달

### ■ 💠 IO Thread

* File API
* IndexedDB
* Storage API(LocalStorage는 동기지만, IndexedDB는 비동기 IO)

### ■ 💠 DOM Thread

* DOM 조작
* 렌더링 트리 생성
* Reflow/Repaint

### ■ 💠 Worker Thread (웹 워커)

* 사용자가 직접 만든 스레드로 CPU 작업 분산

### ■ 💠 GPU Thread (Compositor)

* CSS transform, opacity(합성 레이어)
* Off-main-thread animation

**이 모든 스레드가 Web API의 일부입니다.**

---

# 🛠 3. Web API의 역할(정확히 무엇을 하는가?)

Web API는 JS 엔진이 하지 못하는 일을 대신 수행:

### ✔ (역할 1) 비동기 작업 처리

* 타이머 처리
* 네트워크 IO
* 디스크 IO
* 이벤트 리스너 관리
* 애니메이션 처리

### ✔ (역할 2) Callback 등록·실행 시점 관리

Web API가 일을 마치면:

→ **콜백을 Task Queue 또는 Microtask Queue에 넣음**
→ 이벤트 루프가 그걸 콜 스택으로 실행

### ✔ (역할 3) 브라우저 기능 연결

JS가 브라우저의 기능을 호출할 수 있도록 연결해 줌.

예:

* `document.querySelector` → DOM API
* `console.log` → Web API 내부 stdout 처리
* `fetch` → 네트워크 스레드

### ✔ (역할 4) UI 스레드와 데이터 공유

* DOM은 JS 엔진과 같은 메인 스레드를 공유
* 하지만 렌더링은 별도 스레드(GPU)에서 수행될 수 있음

---

# 📌 4. Web API의 동작 규칙 (정확한 흐름)

### 예제:

```javascript
setTimeout(() => console.log('A'), 1000);
fetch('/data').then(res => console.log('B'));
console.log('C');
```

### 실행 순서:

1. JS 엔진(콜 스택)에서 `setTimeout` 호출
2. Timer Thread가 타이머 등록 후 바로 “반환”
3. `fetch` 호출 → Network Thread가 요청 시작 후 “반환”
4. 콜 스택에서 `console.log("C")` 실행
   → C 출력
5. fetch 응답 도착
   → Web API는 Promise Microtask Queue에 콜백 저장
6. Timer가 1초 뒤 완료
   → Task Queue에 콜백 저장
7. 이벤트 루프는:

   * Microtask Queue 먼저 → “B”
   * 그 후 Task Queue → “A”

### 결과:

```
C
B
A
```

---

# 🌪 5. Web API가 없다면 어떤 일이 벌어지는가?

Web API 없이 “순수 JS 엔진만 존재한다”면:

❌ DOM 조작 불가능
❌ setTimeout 불가능
❌ 이벤트 리스너 불가능
❌ AJAX, Fetch 불가능
❌ 콘솔 출력 불가능

즉,

> JavaScript 엔진만으로는 HTML 렌더링도, 비동기도, 네트워크도 전혀 못 한다.

Web API는 브라우저가 가진 “모든 기능의 다리”이다.

---

# 🔍 6. 주요 Web API Deep Dive

여기서부터가 전문가 영역입니다.

---

## 6-1. Timer API (`setTimeout` / `setInterval`)

많은 개발자가 오해하는 것:

> setTimeout(…, 0)은 “즉시 실행”이 아니다!
> Web API가 최소 수행 시간(4ms 또는 브라우저 정책)을 보장하고
> 그 후 콜백을 Task Queue에 넣을 뿐이다.

Timer Thread에서 실제 API 처리:

* 타이머가 끝나도 → 콜백은 **즉시 실행되는 것이 아니라**
* Task Queue로 이동할 뿐
* 이벤트 루프가 콜 스택이 비었을 때 들어가서 실행됨

---

## 6-2. DOM Event API

DOM 이벤트는 다음 흐름을 갖는다:

1. click/mousemove 등 실제 브라우저 OS 이벤트 발생
2. 브라우저 Event System이 이벤트 객체를 생성
3. 등록된 이벤트 리스너 목록(Web API 내부 구조)에 저장
4. 이벤트 발생 → 콜백을 Task Queue로 이동
5. 이벤트 루프가 실행

중요 포인트:

> 이벤트 리스너 함수는 “바로 실행”되는 것이 아니라
> **Web API → Task Queue → Event Loop → Call Stack**
> 이 4단계를 반드시 거친다.

---

## 6-3. Fetch / XHR (Network API)

네트워크 스레드는:

* 요청 전송
* 응답 대기(비동기)
* TCP/HTTP 핸드셰이크 관리
* 스트림 처리

응답이 끝나면:

* Promise 기반이라 Microtask Queue로 콜백 이동

그래서 fetch.then은 setTimeout보다 먼저 실행된다.

---

## 6-4. WebSocket API

* 소켓 연결 유지
* 수신 이벤트 발생 시 Task Queue로 콜백을 전달
* 네트워크 스레드가 지속적으로 모니터링

---

## 6-5. File API / IndexedDB API

디스크 IO는 네트워크보다 느리기 때문에:

* 전용 IO 스레드에서 수행
* 완료 후 Task Queue / Microtask Queue로 이벤트 전달

IndexedDB는 **엄격하게 비동기**
→ 동기 API가 있으면 UI가 멈추기 때문

---

## 6-6. Worker Threads

웹 워커는 브라우저에서 **메인 스레드와 완전히 분리된 스레드**
Web API의 일부 영역이 별도 스레드를 사용하는 방식

---

# 🧠 7. Web API는 왜 필요할까? (핵심 이유)

### 🟩 1) JavaScript는 싱글 스레드 → 병렬 처리 불가

브라우저는 멀티 스레드 → 이를 Web API가 대신 수행

### 🟩 2) UI 차단 방지

렌더링 스레드와 JS 스레드는 분리되어야 부드러운 UI 가능

### 🟩 3) 비동기 모델 구축

타이머/네트워크/IO 모두 JS 엔진 바깥에서 처리해야 JS가 멈추지 않음

### 🟩 4) 성능 최적화

DOM, 네트워크, 디스크 IO 같은 무거운 작업은 별도 스레드가 적합

---

# 🔥 8. Web API · 콜스택 · 이벤트 루프 관계 요약

```
JS calls Web API →
      Web API (멀티 스레드)에서 작업 수행 →
      완료되면 Queue에 콜백 등록 →
      Event Loop가 큐 확인 →
      콜 스택 비었을 때 콜백을 실행
```

절대 잊지 말 것:

> **Web API는 실행하지 않는다.
> Web API는 "작업을 처리"하고, "콜백을 큐에 넣을 뿐".
> 실행은 오직 JS 엔진(Call Stack).**

---

# 🎯 결론: Web API를 한 문장으로 요약하면?

> **브라우저가 제공하는 모든 비동기 기능과 IO·렌더링·이벤트 시스템을 책임지는 멀티 스레드 기반 런타임이며, JS 엔진과 이벤트 루프를 연결하는 핵심 인프라.**


