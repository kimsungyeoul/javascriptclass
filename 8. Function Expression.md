# 📚 JavaScript 함수 표현식


---

## ✅ 1. 함수 표현식이란?

> 함수 표현식(Function Expression)은 함수를 변수에 **값처럼 할당**하는 방식입니다.

```js
const greet = function(name) {
  console.log("Hello, " + name);
};

greet("Alice"); // Hello, Alice
```

### 🔍 분석

* `function(name) {...}` → **익명 함수**
* 이 함수를 `greet` 변수에 **값처럼 할당**
* 이후 `greet()`로 호출 가능

---

## ✅ 2. 함수 선언식 vs 함수 표현식

| 항목       | 함수 선언식                | 함수 표현식                        |
| -------- | --------------------- | ----------------------------- |
| 문법       | `function greet() {}` | `const greet = function() {}` |
| 함수 이름    | 있음 (`greet`)          | 보통 없음 (익명), 내부용 이름은 가능        |
| 호이스팅     | ✅ 전체 함수가 끌어올려짐        | ❌ 변수 선언만 호이스팅, 초기화는 안 됨       |
| 선언 이전 호출 | 가능                    | 불가능 (`TypeError`)             |

### 🔍 실습

```js
greet(); // ❌ TypeError: greet is not a function

const greet = function() {
  console.log("Hi");
};
```

---

## ✅ 3. 익명 vs 이름 있는 함수 표현식

### 🔸 익명 함수 표현식 (가장 일반적)

```js
const add = function(a, b) {
  return a + b;
};
```

### 🔸 이름 있는 함수 표현식 (디버깅·재귀용)

```js
const add = function sum(a, b) {
  if (a <= 0) return b;
  return sum(a - 1, b + 1); // ✅ 내부에서 자기 이름으로 재귀 가능
};
```

✅ `sum`은 **add 외부에서는 접근 불가**, 오직 함수 내부에서만 사용됨

---

## ✅ 4. 함수 표현식 실행 흐름도

```
[스크립트 실행 시작]
      ↓
  greet();        → ❌ 에러 (아직 선언 안 됨)
      ↓
const greet = function() {...};
      ↓
  greet();        → ✅ 정상 호출
```

---

## ✅ 5. 일급 객체로서의 함수

> 자바스크립트 함수는 **값**이다 → 변수에 저장, 인자로 전달, 리턴 가능

```js
function run(fn) {
  fn("World");
}

const sayHello = function(name) {
  console.log("Hello, " + name);
};

run(sayHello); // Hello, World
```

---

## ✅ 6. 디버깅에서의 이름 있는 함수 표현식 장점

```js
const fetchData = function load() {
  // 에러 발생
  throw new Error("fail");
};

fetchData();
```

➡ Chrome DevTools 등 디버거에서 스택 트레이스에 `load` 이름이 표시되어 **문제 함수 파악이 쉬움**

---

## ✅ 7. 실습 문제

### 🔹 Q1. 이름을 받아 인사하는 함수 표현식 만들기

```js
// sayHello("Tom") → Hello, Tom
const sayHello = function(name) {
  console.log("Hello, " + name);
};
sayHello("Tom");
```

---

### 🔹 Q2. 두 값을 곱하는 함수 표현식 만들기

```js
const multiply = function(x, y) {
  return x * y;
};
console.log(multiply(2, 3)); // 6
```

---

### 🔹 Q3. "안녕, 사용자명"을 출력하는 함수 만들기

```js
const greet = function(name) {
  console.log(`안녕, ${name}`);
};
greet("수진"); // 안녕, 수진
```

---

## ✅ 8. 리팩토링 예제

### 🔹 Before: 중복된 코드

```js
console.log("안녕하세요, Alice");
console.log("안녕하세요, Bob");
console.log("안녕하세요, Carol");
```

### 🔹 After: 함수 표현식으로 리팩토링

```js
const sayHello = function(name) {
  console.log(`안녕하세요, ${name}`);
};

sayHello("Alice");
sayHello("Bob");
sayHello("Carol");
```

➡ 코드 중복 제거, 가독성/재사용성 향상

---

## ✅ 9. 요약 정리

| 항목       | 함수 표현식의 특징                       |
| -------- | -------------------------------- |
| 정의 방식    | 함수를 변수에 값처럼 할당                   |
| 이름       | 대부분 익명, 필요 시 이름 부여 가능 (디버깅, 재귀용) |
| 호이스팅     | ❌ 함수 본문은 호이스팅 안 됨                |
| 실행 가능 시점 | 선언된 이후부터만 가능                     |
| 값으로서의 함수 | ✅ 변수에 저장, 인자로 전달, 리턴 가능 (1급 객체)  |

---

## 🧪 보너스 실습 (심화)

### ❓ 익명 함수 vs 이름 있는 함수, 재귀 차이 실험

```js
const a1 = function(x) {
  if (x <= 0) return 0;
  return a1(x - 1); // 외부 변수명 의존
};

const a2 = function recur(x) {
  if (x <= 0) return 0;
  return recur(x - 1); // 함수 내부 이름으로 재귀
};

const b1 = a1;
a1 = null;

const b2 = a2;
a2 = null;

b1(3); // ❌ TypeError: a1 is not a function
b2(3); // ✅ 정상 실행: 내부 이름 recur 사용
```

