자바스크립트의 `async/await`는
**“비동기 코드를 동기 코드처럼 읽게 해주는 문법 설탕(syntax sugar)”** 입니다. 🍯
하지만 단순히 “보기 좋다” 수준이 아니라, **에러 처리, 흐름 제어, 가독성** 측면에서 설계 철학이 꽤 깊습니다.

---

## 0. 왜 `async/await`가 등장했나? 🤯

자바스크립트 비동기 역사는 대략 이렇게 흘렀습니다.

1. **콜백(callback)**

   ```js
   doSomething((err, result) => {
     if (err) return handleError(err);
     doAnother(result, (err, result2) => {
       if (err) return handleError(err);
       // ...
     });
   });
   ```

   * 중첩 중첩 중첩… → **콜백 지옥**
   * 에러 흐름이 복잡, 재사용도 낮음.

2. **Promise**

   ```js
   doSomething()
     .then(result => doAnother(result))
     .then(result2 => ...)
     .catch(handleError);
   ```

   * 체이닝으로 구조가 수평으로 펴짐.
   * 하지만 then/catch가 많아지면 여전히 **흐름이 눈에 안 들어옴**.

3. **async/await**

   ```js
   async function main() {
     try {
       const result = await doSomething();
       const result2 = await doAnother(result);
       // ...
     } catch (err) {
       handleError(err);
     }
   }
   ```

   * `try/catch`와 변수 대입으로 **정말 동기 코드처럼 읽힌다**.
   * 실제로는 **여전히 Promise 기반**이며, **event loop는 그대로**다.

즉, `async/await`는 **새로운 비동기 메커니즘이 아니라**

> “Promise를 더 인간 친화적인 문법으로 감싼 것”
> 이라고 보는 것이 정확합니다. 🧠

---

## 1. `async` 함수란 무엇인가? 🔍

### 1-1. 정의: `async function`은 **항상 Promise를 반환**한다

```js
async function foo() {
  return 1;
}

const result = foo();
console.log(result); // 👉 Promise { 1 }
```

표면적으로는 `1`을 반환하는 것처럼 보이지만, 실제로는 다음과 같습니다.

```js
function foo() {
  return Promise.resolve(1);
}
```

즉:

* `async` 함수의 **리턴 값 → 자동으로 `Promise.resolve(...)`로 래핑**된다.
* 명시적으로 `return Promise.resolve(1)`을 써도 되고, 그냥 `return 1` 해도 된다.
* 예외가 발생하면 자동으로 **reject된 Promise**가 된다.

```js
async function bar() {
  throw new Error("boom!");
}

bar().catch(err => console.log(err.message)); // "boom!"
```

위 코드는 내부적으로 대략 이렇게 변환된다고 생각하면 됩니다.

```js
function bar() {
  return Promise.reject(new Error("boom!"));
}
```

### 1-2. `async`가 붙을 수 있는 곳들

```js
async function f1() {}             // 함수 선언
const f2 = async () => {};         // 함수 표현식 (화살표 함수)
const obj = {
  async method() {}                // 객체 메서드
};
class C {
  async method() {}                // 클래스 메서드
}
```

어디에 붙든 공통점은 단 하나:

> **“반환 타입이 항상 Promise가 된다”** ✅

---

## 2. `await`의 의미: “잠시 멈춰… 하지만 스레드는 막지 마” 🛑➡️🏃

### 2-1. 기본 문법

```js
const value = await somePromise;
```

동작 개념:

1. `somePromise`가 **Promise가 아닌 값**이면
   → 내부적으로 `Promise.resolve(somePromise)`로 바뀐다.
2. 그 Promise가 **fulfilled** 될 때까지 해당 `async` 함수의 **실행을 일시 중단**한다.
3. fulfilled 값이 `value`에 대입되어, 그 다음 줄부터 코드를 계속 실행한다.
4. 만약 Promise가 **rejected** 되면
   → 해당 지점에서 예외가 던져진 것처럼 처리된다 (→ `try/catch`로 잡을 수 있음).

### 2-2. “실행을 멈춘다”는 말의 진짜 의미 ⚙️

중요한 포인트:

* `await`는 **“함수 전체를 블록(block)하는 게 아니라, 그 함수의 실행 컨텍스트를 일시 중단”** 한다.
* **자바스크립트의 단일 스레드(event loop)는 계속 돌아간다.**
* `await`를 만나면:

  1. 현재 `async` 함수는 Promise를 반환하고,
  2. 나머지 코드는 **나중에 microtask 큐에 재등록**되었다가
  3. Promise가 해결된 시점에 **다시 이어서 실행**된다.

즉, `await`는 **동기 코드처럼 보이지만 내부적으로는 Promise 체인으로 분해**됩니다.

간단한 예:

```js
async function demo() {
  console.log("A");
  await Promise.resolve();
  console.log("B");
}
console.log("1");
demo();
console.log("2");
// 실행 순서: 1, A, 2, B
```

`A`까지는 즉시 실행되지만, `await` 이후의 `B`는 **다음 microtask 턴에 실행**됩니다.

---

## 3. 기본 패턴: 순차 vs 병렬 ⏱️⚡

### 3-1. 순차 실행 (Sequential)

```js
async function fetchSequential() {
  const user = await fetchUser();        // 1
  const orders = await fetchOrders(user.id); // 2
  const stats = await fetchStats(user.id);   // 3

  return { user, orders, stats };
}
```

특징:

* 2번, 3번은 **앞선 결과에 의존**한다면 이렇게 순차 실행이 필요.
* 각 `await`가 끝날 때까지 다음 줄로 넘어가지 않는다 (물론 스레드는 블록되지 않음).

내부적으로는:

```js
fetchUser()
  .then(user => fetchOrders(user.id)
    .then(orders => fetchStats(user.id)
      .then(stats => ({ user, orders, stats }))
    )
  );
```

와 비슷한 Promise 체인 구조입니다.

### 3-2. 병렬 실행 (Parallel)

의존성이 없는 비동기 작업은 **동시에 실행하는 것이 훨씬 효율적**입니다.

```js
async function fetchParallel(userId) {
  const userPromise = fetchUser(userId);
  const orderPromise = fetchOrders(userId);
  const statsPromise = fetchStats(userId);

  const [user, orders, stats] = await Promise.all([
    userPromise,
    orderPromise,
    statsPromise,
  ]);

  return { user, orders, stats };
}
```

핵심:

* `await`를 **각각의 호출에 즉시 붙이지 말고**,
  **먼저 Promise를 다 “발사”한 후** 한 번에 `Promise.all`로 기다리기.

잘못된(비효율적인) 예:

```js
// ❌ 이건 병렬이 아니라 사실상 순차 실행
async function badExample(userId) {
  const user = await fetchUser(userId);
  const orders = await fetchOrders(userId);
  const stats = await fetchStats(userId);
}
```

---

## 4. 에러 처리: `try/catch`와 Promise 에러의 조화 ⚠️

### 4-1. 단일 `await`의 에러 처리

```js
async function main() {
  try {
    const data = await fetchData();
    console.log("success", data);
  } catch (err) {
    console.error("failed", err);
  }
}
```

* `fetchData()`가 반환한 Promise가 **reject**되면
  → `await` 표현식에서 **예외가 던져진 것처럼** 동작.
* 따라서 기존 동기 코드 스타일의 `try/catch`를 사용할 수 있게 됨.

### 4-2. 여러 `await`와 에러 위치

```js
async function process() {
  try {
    const user = await fetchUser();         // 여기서 reject될 수도 있고
    const orders = await fetchOrders(user); // 여기서 reject될 수도 있고
    const payment = await charge(user);     // 여기서도 가능
    return payment;
  } catch (e) {
    console.error("어디선가 실패:", e);
    throw e;
  }
}
```

한 번의 `try/catch`로 감싸면 어디서 실패했는지 **스택 트레이스로 확인**할 수 있습니다.
필요하다면 **에러를 구분해서 처리**하는 것도 가능하죠.

```js
async function process() {
  const user = await fetchUser().catch(e => {
    console.error("유저 조회 실패", e);
    throw e; // 다시 던져도 되고, 기본값 리턴도 가능
  });

  const orders = await fetchOrders(user).catch(e => {
    console.error("주문 조회 실패", e);
    return []; // 기본값 처리
  });

  return orders;
}
```

---

## 5. 루프 + `await`: `for` vs `forEach` ⚙️

### 5-1. `forEach` 안에서 `await` 사용은 대부분 함정 ❌

```js
async function bad() {
  [1, 2, 3].forEach(async (id) => {
    const data = await fetchById(id);
    console.log(data);
  });
  console.log("끝"); // 이게 먼저 찍힐 수 있음
}
```

문제점:

* `forEach`는 콜백의 Promise를 기다려 주지 않는다.
* `bad()` 함수는 **각 콜백의 완료를 기다리지 않고** 바로 리턴해 버린다.
* 로그 순서도 직관과 다르게 나온다.

### 5-2. **순차적으로** 돌리고 싶다면 `for...of` ✅

```js
async function processSequential(ids) {
  for (const id of ids) {
    const data = await fetchById(id);
    console.log("처리 완료:", id, data);
  }
  console.log("모두 끝");
}
```

* 각 반복마다 `await`로 기다리므로 **완전한 순차 실행**.
* 처리 순서가 중요할 때 / 외부 리소스를 차례대로 접근해야 할 때 적합.

### 5-3. 병렬 처리 + 루프: `map` + `Promise.all` ⚡

```js
async function processParallel(ids) {
  const promises = ids.map(id => fetchById(id));
  const results = await Promise.all(promises);
  console.log("모두 끝", results);
}
```

* 모든 요청을 동시에 날린 뒤 한 번에 기다린다.
* **독립적인 작업**이라면 이 패턴이 가장 효율적.

---

## 6. 기존 콜백 기반 API를 `async/await`로 사용하는 방법 🔄

현실에서는 여전히 콜백 스타일 API가 많습니다. (Node.js의 `fs.readFile` 등)

### 6-1. 직접 Promise로 감싸기

```js
function readFilePromise(path) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, "utf8", (err, data) => {
      if (err) return reject(err);
      resolve(data);
    });
  });
}

async function showFile() {
  try {
    const content = await readFilePromise("./data.txt");
    console.log(content);
  } catch (e) {
    console.error("파일 읽기 실패", e);
  }
}
```

이렇게 하나의 래퍼를 만들어 놓으면 이후로는 **완전히 async/await 스타일**로 사용할 수 있습니다.

### 6-2. Node.js의 `util.promisify` (참고)

Node 환경에서는:

```js
const { promisify } = require("util");
const readFileAsync = promisify(fs.readFile);

async function showFile() {
  const content = await readFileAsync("./data.txt", "utf8");
  console.log(content);
}
```

---

## 7. `async/await` 내부 메커니즘: Promise 체인으로의 변환 👩‍💻

간단한 예를 실제로 “머릿속 변환” 해 봅시다.

```js
async function example() {
  const a = await f1();
  const b = await f2(a);
  return b * 2;
}
```

이 코드는 내부적으로 대략 이런 식입니다.

```js
function example() {
  return f1()
    .then(a => f2(a))
    .then(b => b * 2);
}
```

에러 처리를 포함하면:

```js
async function example() {
  try {
    const a = await f1();
    const b = await f2(a);
    return b * 2;
  } catch (e) {
    console.error(e);
    throw e;
  }
}
```

↓ Promise 스타일로 표현하면:

```js
function example() {
  return f1()
    .then(a => f2(a))
    .then(b => b * 2)
    .catch(e => {
      console.error(e);
      throw e;
    });
}
```

이 관점을 가지면:

* `async/await`와 `Promise`의 상호 변환이 자연스럽게 이해되고,
* 라이브러리 코드가 Promise 체인을 사용하더라도 **마음속으로 async/await 버전을 그려 볼 수 있습니다.**

---

## 8. 흔한 함정 & 베스트 프랙티스 ✅❌

### 8-1. “모든 비동기를 무조건 `await`로 감싸야 한다”는 오해 ❌

때로는 **“fire-and-forget”** 스타일이 필요합니다.

```js
async function handleRequest(req) {
  // 응답은 빨리 주고
  res.send("OK");

  // 로깅은 백그라운드로
  doBackgroundLogging(req); // await ❌
}
```

* 정말 결과가 필요 없다면, 굳이 `await`로 기다릴 필요가 없습니다.
* 다만 에러 처리를 어떻게 할 것인지(전역 핸들러, 로그 등)는 고민해야 합니다.

### 8-2. `await`를 너무 자주, 너무 세밀하게 사용 ❌

```js
// ❌ 성능 나쁜 예
async function slow() {
  const a = await getA();
  const b = await getB();
  const c = await getC();
  return a + b + c;
}
```

가능하면 **병렬로**:

```js
// ✅ 빠른 예
async function fast() {
  const [a, b, c] = await Promise.all([getA(), getB(), getC()]);
  return a + b + c;
}
```

### 8-3. 상위 레벨에서 `await`를 잊어버리는 실수

```js
async function getData() {
  const result = await fetch("/api/data");
  return result.json();
}

const data = getData();  // ❌ data는 Promise
console.log(data.someField); // TypeError
```

해결:

```js
const data = await getData(); // 상위 함수도 async여야 함
```

또는:

```js
getData().then(data => {
  console.log(data.someField);
});
```

### 8-4. `try/catch`가 잡지 못하는 에러

* `async` 함수 안에서 만든 **비동기 작업을 `await`하지 않으면**,
  그 작업의 에러는 해당 `try/catch`에서 잡지 못할 수 있습니다.

```js
async function foo() {
  try {
    setTimeout(() => {
      throw new Error("timeout 에러");
    }, 0);
  } catch (e) {
    // ❌ 여기는 안 잡힘
  }
}
```

* 이건 `setTimeout` 자체가 Promise 기반이 아니고, 완전히 다른 call stack에서 실행되기 때문입니다.
* 이런 경우엔 **Promise 기반 API**로 래핑해서 `await`로 기다리거나, 전역 에러 핸들러를 사용해야 합니다.

---

## 9. 상위 레벨(엔트리 포인트)에서의 패턴 🏁

### 9-1. 최상위 async 함수에서 에러를 처리하는 패턴 (Node.js CLI 등)

```js
async function main() {
  try {
    const data = await complexAsyncFlow();
    console.log("완료:", data);
  } catch (e) {
    console.error("치명적 에러:", e);
    process.exit(1);
  }
}

main();
```

* “프로그램의 시작점”에서는 이런 패턴이 자주 쓰입니다.
* 웹 서버라면 `Express`나 `Koa`의 미들웨어 체인에서,
  프레임워크가 제공하는 에러 핸들러로 넘기기도 합니다.

---

## 10. 정리: `async/await`를 머릿속에 이렇게 저장해 두면 편합니다 🧠✨

1. `async` 함수는
   → **항상 Promise를 반환**한다. (`return 1` → `Promise.resolve(1)`)

2. `await`는
   → Promise를 **“일시 정지 + 이어 실행”** 패턴으로 풀어 주는 문법이다.

3. 에러는
   → `await` 시점에서 예외로 튀어나와 기존 `try/catch`로 처리 가능하다.

4. 루프에서는
   → `forEach` 안에서 `await` 쓰지 말고,
   → **순차**는 `for...of`, **병렬**은 `map + Promise.all`.

5. 성능 관점에서
   → 독립적인 비동기 작업은 **최대한 병렬**로.
   → 의존성이 있는 작업만 **순차**로.

6. 기존 콜백 API
   → 한 번 Promise로 래핑해 두면 이후에는 `async/await` 세계로 편입 가능.

