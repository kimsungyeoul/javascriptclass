# 🧑‍🏫 JavaScript 함수(Function)



## 1. 함수(Function)의 정의

**함수(Function)** 란?

* 하나의 **작업 단위**를 정의한 코드 블록
* 재사용 가능하고, 입력(파라미터)을 받아, 결과(리턴값)를 생성

```js
function greet(name) {
  return `안녕하세요, ${name}님!`;
}
```

<span style="color:red">"함수는 자바스크립트의 1급 객체입니다. 즉, 변수에 저장하거나, 아규먼트로 전달하거나, 반환값으로 사용할 수 있습니다."</span>

---

## 2. 함수 선언 방식 (종류)

### ✅ 2.1 함수 선언문 (Function Declaration)

```js
function sayHello() {
  console.log("Hello!");
}

sayHello();
```

* **호이스팅(hoisting)** O → 코드 상단으로 끌어올려져서 선언 전에도 호출 가능

---

### ✅ 2.2 함수 표현식 (Named Function Expression)

```js
const sayBye = function() {
  console.log("Goodbye!");
};

sayBye();
```

* 호이스팅 X → 변수처럼 동작
* **익명 함수** 또는 **기명 함수**로 작성 가능

---

### ✅ 2.3 화살표 함수 (Arrow Function)

```js
const add = (a, b) => a + b;

add();
```

* `this`, `arguments`, `super`, `new.target` 바인딩을 **상속받음** (자체 바인딩 없음)
* **짧고 간결한 함수**에 유리
* **객체 메서드에는 부적합**

```js
const obj = {
  count: 0,
  inc: () => { this.count++ } // this가 obj가 아님
};

obj.inc();
```

---

## 3. 파라미터와 아규먼트

| 구분               | 설명                |
| ---------------- | ----------------- |
| 파라미터 (Parameter) | 함수 선언 시 받는 입력값 이름 |
| 아규먼트 (Argument)  | 함수 호출 시 전달하는 실제 값 |

```js
function multiply(a, b) { // a, b → 파라미터
  return a * b;
}
multiply(2, 3); // 2, 3 → 아규먼트
```

---

### ✅ 디폴트 파라미터 (Default Parameters)

```js
function greet(name = "손님") {
  console.log(`안녕하세요, ${name}`);
}

greet("철수"); // 출력: 안녕하세요, 철수
greet(); // 출력: 안녕하세요, 손님
greet(undefined); // 출력: 안녕하세요, 손님

```

---

### ✅ 나머지 파라미터 (Rest Parameters)

```js
function sum(...numbers) {
  return numbers.reduce((acc, n) => acc + n, 0);
}

// 1. 여러 개의 인자 전달
console.log(sum(1, 2, 3));          // 결과: 6

// 2. 더 많은 인자 전달
console.log(sum(10, 20, 30, 40));   // 결과: 100

// 3. 인자가 없는 경우
console.log(sum());                 // 결과: 0 (초기값 0 반환)
```

> reduce는 배열의 각 요소를 순회하며 하나의 최종 결괏값을 만들어내는 자바스크립트의 가장 강력한 배열 메서드 중 하나입니다.

---

## 4. 함수의 반환값 (Return)

* `return` 키워드를 사용해 값을 리턴
* 함수는 항상 `undefined` 또는 명시된 값을 리턴함

```js
function square(x) {
  return x * x;
}
```

---

## 5. 콜백 함수 (Callback)

> 다른 함수의 아규먼트로 전달되는 함수

```js
function processUserInput(callback) {
  const name = "철수";
  callback(name);
}

// 함수 호출: 아규먼트로 '익명 함수'를 통째로 전달함
processUserInput(function(name) {
  console.log(`환영합니다, ${name}님`);
});
```

---

## 6. 고차 함수 (Higher-Order Function)

> 함수를 아규먼트로 받거나, 함수를 리턴하는 함수

```js
function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = multiplier(2);
console.log(double(10)); // 20
```

---

## 7. 즉시 실행 함수 (IIFE)

> Immediately Invoked Function Expression
> 선언과 동시에 실행됨

```js
(function () {
  console.log("즉시 실행됨");
})();
```

---

## 8. 함수 스코프와 클로저

### ✅ 스코프(Scope)

* 함수는 **자신이 선언된 렉시컬 환경**에서 변수에 접근
* 블록 스코프 (`let`, `const`) vs 함수 스코프 (`var`)

### ✅ 클로저(Closure)

> 함수가 외부 함수의 변수에 접근하는 현상

```js
function outer() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2
```

---

## 9. 재귀 함수 (Recursion)

> 함수가 자기 자신을 호출하는 함수

```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}
```

---

## 10. this와 함수

### ✅ 일반 함수 vs 화살표 함수의 this 차이

```js
const obj = {
  value: 42,
  method() {
    console.log(this.value); // 42
  },
  arrow: () => {
    console.log(this.value); // undefined (전역)
  }
};

obj.method(); // 출력: 42 (obj가 호출했으므로 this는 obj)
obj.arrow();  // 출력: undefined (선언될 당시 상위 스코프의 this를 가리킴),
              //       자바스크립트에서 이 현상이 발생하는 이유는 화살표 함수는 자신만의 this를 가지지 않기 때문입니다. 이를 전문 용어로 렉시컬 디스(Lexical this)라고 부릅니다.
```

```
const obj = { // 1. 여기서 객체가 생성되지만, 스코프는 여전히 '전역'입니다.
  value: 42,
  arrow: () => { 
    // 2. 이 함수가 선언되는 시점에 자신을 감싸고 있는 '진짜 스코프'를 찾습니다.
    // 3. obj는 스코프가 아니므로, 그 바깥인 '전역(window 또는 global)'을 가리키게 됩니다.
    console.log(this.value); 
  }
};
```

---

## 11. arguments 객체

> 함수 내부에서 사용 가능한 **유사 배열 객체**

```js
function show() {
  console.log(arguments);
}
show(1, 2, 3); // [1, 2, 3]
```

> 화살표 함수에는 `arguments` 없음

---

## 12. 이름 있는 함수 vs 익명 함수

| 항목    | 이름 있는 함수           | 익명 함수         |
| ----- | ------------------ | ------------- |
| 디버깅   | 스택 트레이스에서 이름 확인 가능 | 이름 없음         |
| 재귀    | 함수 안에서 자기 자신 호출 가능 | 어려움           |
| 일반적으로 | 선언문 또는 기명 표현식      | 이벤트 핸들러, 콜백 등 |

---

## 13. 함수 메모리 절약 전략 (캐싱/메모이제이션)

```js
function memoizedFactorial() {
  const cache = {};
  return function f(n) {
    if (cache[n]) return cache[n];
    cache[n] = n === 1 ? 1 : n * f(n - 1);
    return cache[n];
  };
}
```



---

## 🧠 마무리 요약

| 주제        | 핵심 요점                 |
| --------- | --------------------- |
| 함수 선언 방식  | 선언문, 표현식, 화살표         |
| 함수 특성     | 1급 객체, 클로저, 콜백, 고차 함수 |
| this 바인딩  | 일반 함수 vs 화살표 함수       |
| 파라미터/아규먼트 | 디폴트값, rest, arguments  |
| 활용 전략     | 메모이제이션, 스코프, 즉시 실행    |


