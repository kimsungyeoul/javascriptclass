# 🚨 **호이스팅은 애초에 의도적으로 만든 기능이 아니다.**

# 🚨 **JS 초기에 ‘급하게 만든 언어의 부작용’이다.**

진짜입니다.
이건 공식 역사이고, 브렌던 아이크(자바스크립트 창시자)가 직접 인정한 내용입니다.

---

# 🔥 1. JS가 10일 만에 만들어진 언어였기 때문

1995년, Netscape 브라우저 팀이

* “웹페이지에 간단한 스크립트 언어 필요함”
* “브라우저 출시까지 2주 남음”
* “Java랑 비슷하게 보이게 만들어라”
* “하지만 문법은 매우 단순하게, 초보들도 쓰게”

이런 조건으로 언어를 만들라고 지시함.

그래서 브렌던 아이크가 **10일 만에** 만들었음.
(믿기 힘들지만 진짜임)

그래서 구조가 다음처럼 됨:

* C 같은 문법
* Scheme(함수형)에서 스코프 체인 끌어옴
* Java처럼 “선언은 위에서 해야 한다”는 느낌도 유지하려고 함
* 근데 정적 언어가 아니라서 선언문이 어디든 나올 수 있음

→ 이 혼종 설계가 “호이스팅”이라는 개판 구조를 낳음.

---

# 🔥 2. 엔진의 “실행 모델” 때문에 자연스럽게 나타난 현상

자바스크립트 엔진은 코드를 두 단계로 실행합니다:

1. **선언 수집 (Creation phase)**

   * 함수 선언 찾음
   * 변수 선언 찾음
   * 스코프에 이름 먼저 등록

2. **실제 실행 (Execution phase)**

   * 코드를 한 줄씩 실행
   * 값이 할당됨

여기서 문제:

```
console.log(a);
var a = 10;
```

이걸 읽으려면 엔진이 “실행 전에 선언을 스캔”해야만 함.

선언을 스캔하는 과정 = 이름을 미리 올려놓는 과정
→ 이것이 나중에 이름 붙은 것 = **호이스팅(끌어올림)**

즉:

### ❗ 엔진이 스코프를 먼저 준비해야 하는 구조 때문에 “부작용”으로 생긴 개념

의도된 기능이 아니라, **엔진 구조 때문**에 이렇게 동작해버린 것.

---

# 🔥 3. Java 같은 정적 언어처럼 보이게 만들려고 했지만 실패함

JS는 원래 “자바의 동생 느낌”을 주려고 했습니다.

Java는:

```java
int x;
System.out.println(x); // ❌ 컴파일 에러
```

하지만 JS는:

* 선언 위치가 들쑥날쑥해도 실행되고
* 타입도 자유롭고
* 실행 중에 선언문이 등장할 수도 있고

그래서 “선언을 먼저 수집해야 한다”
→ 그 결과 “호이스팅처럼 보이는 동작”이 생긴 것.

---

# 🔥 4. let/const 시대에도 호이스팅은 제거할 수 없었던 이유

왜 let/const는 호이스팅을 **없애지** 않았을까?

왜냐하면 **엔진 구조 자체가 선언을 실행 전에 수집하도록 설계되어 있기 때문**.

그래서 let/const는 “호이스팅은 되지만 초기화는 안 하는 방식”으로 도입된 거임.

이를 안전하게 만들려고:

* **TDZ** 등장
* 선언문 도달 전 접근 금지
* var의 부작용 해결

---

# 🔥 결론: 호이스팅은 "필요해서 만든 게 아니라, 엔진 구조 + JS 초창기 설계가 만든 부작용"

요약하자면:

### ✔ JS는 선언을 실행 전에 스캔해야 동작함

### ✔ 변수/함수를 미리 스코프에 등록하는 과정이 생김

### ✔ 이게 외부에서 봤을 때 “끌어올려진 것처럼 보여서” → 호이스팅

### ✔ var는 undefined로 초기화해서 더 혼란

### ✔ let/const는 TDZ로 안전하게 변경

---

# 🎯 **즉, 호이스팅은 의도된 기능이 아니다.

JS 초창기 설계 + 엔진 구조의 부작용이다.**

그래서 전 세계 개발자들이 20년간 욕했고
그래서 let/const가 나왔고
그래서 var를 버리라고 하는 것이다.

