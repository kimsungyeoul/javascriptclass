



# 🧠 웹 브라우저의 이벤트 루프

자바스크립트는 **싱글 스레드**지만 브라우저는 **멀티 스레드**입니다. 이 둘의 역할 분리가 JS의 비동기 실행 모델을 만들어냅니다.
핵심 구성 요소는 아래 4개입니다:

1. **Call Stack (콜 스택)**
2. **Web API (브라우저 API)**
3. **Task Queue (태스크/콜백 큐)**
4. **Event Loop (이벤트 루프)**

<img src="./images/event_loop_call_stack_queue.png " width=80% /><br>

이 네 요소가 함께 **논블로킹 비동기 모델**을 구현합니다.

---

# 1️⃣ Call Stack (콜 스택) — 실행의 중심 무대 🎭

## ✔ 정의

콜스택은 **JavaScript 엔진(V8)** 내부에 있으며, **함수 실행 컨텍스트(Function Execution Context)**를 쌓았다가(pop/push) 처리하는 **LIFO(후입선출)** 구조입니다.

즉,
👉 **현재 실행 중인 코드가 무엇인지**
👉 **누가 누구를 호출했는지**
를 관리하는 영역입니다.

## ✔ 특징

* 하나뿐이다 → **싱글 스레드의 핵심**
* 최상단 스택이 비어야만 다음 작업을 실행 가능
* 비동기 작업의 콜백은 절대! 스스로 콜스택에 들어오지 못함
  → **이벤트 루프가 넣어준다**

---

# 2️⃣ Web API — 브라우저가 대신 처리하는 백그라운드 노동자들 ⚙️🧵

자바스크립트 엔진 외부, 즉 **브라우저가 제공하는 API 영역**입니다.

## 대표 Web API 예시 ✨

* `setTimeout`, `setInterval`
* DOM 이벤트 처리 (click, scroll 등)
* AJAX / Fetch API
* Geolocation API
* WebSocket
* File API
* Timer Thread / IO Thread / Network Thread 등

JS 엔진이 하는 일은 단 하나:
➡ **Web API에 작업을 맡기고(return) 즉시 다음 코드를 실행**

이후 Web API는 타이머, 네트워크, IO 등의 별도 스레드에서 작업을 처리합니다.

---

# 3️⃣ Task Queue / Microtask Queue — 대기실 역할 🕒

Web API에서 처리 완료된 콜백은 **콜스택으로 직접 들어오지 못함**
→ 반드시 **큐(Queue)**로 이동 후
→ **이벤트 루프가 콜스택이 비었을 때 넣어준다**

## ✔ 큐의 종류

### ① **Macrotask Queue (Task Queue)**

“일반 태스크 큐”

여기에 들어오는 작업:

* `setTimeout`
* `setInterval`
* DOM 이벤트 콜백
* `setImmediate`(Node)
* AJAX/XHR의 `onreadystatechange`
* 메시지 채널(postMessage)

### ② **Microtask Queue (Job Queue)**

“더 높은 우선순위 큐”

작업 예시:

* **Promise.then / catch / finally**
* `MutationObserver`
* Node의 `process.nextTick`

## 🔥 중요: Microtask Queue는 항상 Task Queue보다 먼저 실행된다!

즉,

```
Call Stack 비었음 →
   Microtask Queue 먼저 비움 →
   비워지면 Task Queue 처리
```

---

# 4️⃣ Event Loop (이벤트 루프) — 전체를 조율하는 지휘자 🎼

Event Loop의 역할은 단 하나:

👉 **콜스택이 비었는지 확인하고, 큐에 있는 작업을 콜스택으로 넣어주는 것**

매 사이클마다 아래 순서로 실행됩니다:

1. 🎯 콜스택이 비었는지 체크
2. 📌 Microtask Queue 비우기
3. 📌 Task Queue에서 하나 가져오기
4. 🌀 다시 반복

이 간단한 규칙이 자바스크립트의 비동기 시스템 전체를 만든다!

---

# 🏗 전체 흐름도 (초간단 요약)

```
(1) JS 코드 실행
      ↓
(2) 비동기 함수 호출 → Web API에게 위임
      ↓
(3) Web API가 작업 완료 → 콜백을 Task/Microtask Queue로 이동
      ↓
(4) Event Loop가 Call Stack이 비는 순간을 감지
      ↓
(5) Microtask Queue → Call Stack
      ↓
(6) Task Queue → Call Stack
```

---

# ⚡ 예제 1: setTimeout과 Promise의 우선순위 차이

```javascript
console.log("A");

setTimeout(() => console.log("B"), 0);

Promise.resolve().then(() => console.log("C"));

console.log("D");
```

## 실행 결과는?

```
A
D
C
B
```

### 이유 🔍

1. **A** 실행
2. setTimeout은 Web API로 보냄 → 0ms 지나면 Task Queue로 이동
3. Promise.then은 Microtask Queue로 이동
4. **D** 실행
5. 콜스택 비었음 → Microtask Queue 먼저 → **C**
6. 그 후 Task Queue → **B**

---

# ⚡ 예제 2: Event Loop 때문에 무한 루프처럼 보이는 현상

```javascript
while (true) { }
```

이 코드를 실행하면?

* 콜스택이 비지 않음
* 이벤트 루프는 큐에 쌓인 콜백을 절대 가져올 수 없음
* 브라우저가 "페이지 응답 없음" 상태로 빠짐

👉 자바스크립트 비동기가 잘 동작하려면 **콜스택이 자주 비어야 한다**!

---

# ✔ 정리: 각 요소의 역할 한 문장 요약

| 구성 요소               | 역할                        |
| ------------------- | ------------------------- |
| **Call Stack**      | JS 함수 실행 공간               |
| **Web API**         | 백그라운드 비동기 작업 처리           |
| **Microtask Queue** | Promise 같은 고우선순위 콜백 대기 공간 |
| **Task Queue**      | 타이머, 이벤트 등 일반 콜백 대기       |
| **Event Loop**      | 큐 → 콜스택 이동을 관리하는 스케줄러     |

---

# 📌 결론

웹 브라우저는 단순히 자바스크립트를 실행하는 것이 아니라
**멀티 스레드(Web API) + 싱글 스레드(JS 엔진) + 이벤트 루프** 구조를 활용해
효율적인 비동기 환경을 제공하는 것입니다.

이 구조를 이해하면
✔ 비동기 코드가 언제 실행되는지
✔ Promise가 setTimeout보다 왜 먼저 실행되는지
✔ 무거운 작업이 왜 브라우저를 멈추게 하는지
✔ async/await 동작 원리
까지 전부 명확하게 이해할 수 있습니다.




